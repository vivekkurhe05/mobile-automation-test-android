"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _node = _interopRequireDefault(require("rewiremock/node"));

var _sinon = _interopRequireDefault(require("sinon"));

const expect = chai.expect;
describe('ExtensionConfig', function () {
  describe('getGenericConfigProblems()', function () {
    it('should have some tests');
  });
  describe('DriverConfig', function () {
    let DriverConfig;
    let mocks;
    let sandbox;
    beforeEach(function () {
      mocks = {
        'resolve-from': _sinon.default.stub().callsFake((cwd, id) => _path.default.join(cwd, id))
      };
      DriverConfig = _node.default.proxy(() => require('../lib/driver-config'), mocks).default;
      sandbox = _sinon.default.createSandbox();
    });
    afterEach(function () {
      sandbox.restore();
    });
    describe('extensionDesc()', function () {
      it('should return the description of the extension', function () {
        const config = DriverConfig.getInstance('/tmp/');
        config.extensionDesc('foo', {
          version: '1.0',
          automationName: 'bar'
        }).should.equal(`foo@1.0 (automationName 'bar')`);
      });
    });
    describe('getConfigProblems()', function () {
      let driverConfig;
      beforeEach(function () {
        driverConfig = DriverConfig.getInstance('/tmp/');
      });
      describe('when provided no arguments', function () {
        it('should throw', function () {
          (() => driverConfig.getConfigProblems()).should.throw();
        });
      });
      describe('property `platformNames`', function () {
        describe('when provided an object with no `platformNames` property', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getConfigProblems({}, 'foo').should.deep.include({
              err: 'Missing or incorrect supported platformNames list.',
              val: undefined
            });
          });
        });
        describe('when provided an object with an empty `platformNames` property', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getConfigProblems({
              platformNames: []
            }, 'foo').should.deep.include({
              err: 'Empty platformNames list.',
              val: []
            });
          });
        });
        describe('when provided an object with a non-array `platformNames` property', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getConfigProblems({
              platformNames: 'foo'
            }, 'foo').should.deep.include({
              err: 'Missing or incorrect supported platformNames list.',
              val: 'foo'
            });
          });
        });
        describe('when provided a non-empty array containing a non-string item', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getConfigProblems({
              platformNames: ['a', 1]
            }, 'foo').should.deep.include({
              err: 'Incorrectly formatted platformName.',
              val: 1
            });
          });
        });
      });
      describe('property `automationName`', function () {
        describe('when provided an object with a missing `automationName` property', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getConfigProblems({}, 'foo').should.deep.include({
              err: 'Missing or incorrect automationName',
              val: undefined
            });
          });
        });
        describe('when provided a conflicting automationName', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getConfigProblems({
              automationName: 'foo'
            }, 'foo');
            driverConfig.getConfigProblems({
              automationName: 'foo'
            }, 'foo').should.deep.include({
              err: 'Multiple drivers claim support for the same automationName',
              val: 'foo'
            });
          });
        });
      });
    });
    describe('getSchemaProblems()', function () {
      let driverConfig;
      beforeEach(function () {
        driverConfig = DriverConfig.getInstance('/tmp/');
      });
      describe('when provided an object with a defined non-string `schema` property', function () {
        it('should return an array with an associated problem', function () {
          driverConfig.getSchemaProblems({
            schema: []
          }, 'foo').should.deep.include({
            err: 'Incorrectly formatted schema field; must be a path to a schema file or a schema object.',
            val: []
          });
        });
      });
      describe('when provided a string `schema` property', function () {
        describe('when the property ends in an unsupported extension', function () {
          it('should return an array with an associated problem', function () {
            driverConfig.getSchemaProblems({
              schema: 'selenium.java'
            }, 'foo').should.deep.include({
              err: 'Schema file has unsupported extension. Allowed: .json, .js, .cjs',
              val: 'selenium.java'
            });
          });
        });
        describe('when the property contains a supported extension', function () {
          describe('when the property as a path cannot be found', function () {
            it('should return an array with an associated problem', function () {
              const problems = driverConfig.getSchemaProblems({
                installPath: '/usr/bin/derp',
                pkgName: 'doop',
                schema: 'herp.json'
              }, 'foo');
              problems[0].err.should.match(/Unable to register schema at path herp\.json/i);
            });
          });
          describe('when the property as a path is found', function () {
            it('should return an empty array', function () {
              const problems = driverConfig.getSchemaProblems({
                pkgName: 'fixtures',
                installPath: __dirname,
                schema: 'driver.schema.js'
              }, 'foo');
              problems.should.be.empty;
            });
          });
        });
      });
    });
    describe('read()', function () {
      let driverConfig;
      beforeEach(function () {
        driverConfig = DriverConfig.getInstance('/tmp/');
        sandbox.spy(driverConfig, 'validate');
      });
      it('should validate the extension', async function () {
        await driverConfig.read();
        driverConfig.validate.should.have.been.calledOnce;
      });
    });
    describe('readExtensionSchema()', function () {
      let driverConfig;
      let extData;
      const extName = 'stuff';
      beforeEach(function () {
        extData = {
          installPath: 'fixtures',
          pkgName: 'some-pkg',
          schema: 'driver.schema.js'
        };
        mocks['resolve-from'].returns(require.resolve('./fixtures/driver.schema.js'));
        driverConfig = DriverConfig.getInstance('/tmp/');
      });
      describe('when the extension data is missing `schema`', function () {
        it('should throw', function () {
          delete extData.schema;
          expect(() => driverConfig.readExtensionSchema(extName, extData)).to.throw(TypeError, /why is this function being called/i);
        });
      });
      describe('when the extension schema has already been registered (with the same schema)', function () {
        it('should not throw', function () {
          driverConfig.readExtensionSchema(extName, extData);
          expect(() => driverConfig.readExtensionSchema(extName, extData)).not.to.throw();
        });
      });
      describe('when the extension schema has not yet been registered', function () {
        it('should resolve and load the extension schema file', function () {
          driverConfig.readExtensionSchema(extName, extData);
          expect(mocks['resolve-from']).to.have.been.calledOnce;
        });
      });
    });
  });
  describe('PluginConfig', function () {
    let PluginConfig;
    let mocks;
    let sandbox;
    beforeEach(function () {
      mocks = {
        'resolve-from': _sinon.default.stub().callsFake((cwd, id) => _path.default.join(cwd, id))
      };
      PluginConfig = _node.default.proxy(() => require('../lib/plugin-config'), mocks).default;
      sandbox = _sinon.default.createSandbox();
    });
    afterEach(function () {
      sandbox.restore();
    });
    describe('extensionDesc()', function () {
      it('should return the description of the extension', function () {
        const config = PluginConfig.getInstance('/tmp/');
        config.extensionDesc('foo', {
          version: '1.0'
        }).should.equal(`foo@1.0`);
      });
    });
    describe('getConfigProblems()', function () {
      let pluginConfig;
      beforeEach(function () {
        pluginConfig = PluginConfig.getInstance('/tmp/');
      });
      describe('when provided no arguments', function () {
        it('should not throw', function () {
          (() => pluginConfig.getConfigProblems()).should.not.throw();
        });
      });
    });
    describe('getSchemaProblems()', function () {
      let pluginConfig;
      beforeEach(function () {
        pluginConfig = PluginConfig.getInstance('/tmp/');
      });
      describe('when provided an object with a defined `schema` property of unsupported type', function () {
        it('should return an array with an associated problem', function () {
          pluginConfig.getSchemaProblems({
            schema: []
          }, 'foo').should.deep.include({
            err: 'Incorrectly formatted schema field; must be a path to a schema file or a schema object.',
            val: []
          });
        });
      });
      describe('when provided a string `schema` property', function () {
        describe('when the property ends in an unsupported extension', function () {
          it('should return an array with an associated problem', function () {
            pluginConfig.getSchemaProblems({
              schema: 'selenium.java'
            }, 'foo').should.deep.include({
              err: 'Schema file has unsupported extension. Allowed: .json, .js, .cjs',
              val: 'selenium.java'
            });
          });
        });
        describe('when the property contains a supported extension', function () {
          describe('when the property as a path cannot be found', function () {
            it('should return an array with an associated problem', function () {
              const problems = pluginConfig.getSchemaProblems({
                installPath: '/usr/bin/derp',
                pkgName: 'doop',
                schema: 'herp.json'
              }, 'foo');
              problems[0].err.should.match(/Unable to register schema at path herp\.json/i);
            });
          });
          describe('when the property as a path is found', function () {
            it('should return an empty array', function () {
              const problems = pluginConfig.getSchemaProblems({
                pkgName: 'fixtures',
                installPath: __dirname,
                schema: 'plugin.schema.js'
              }, 'foo');
              problems.should.be.empty;
            });
          });
        });
      });
      describe('when provided an object `schema` property', function () {
        it('should return an empty array', function () {
          const problems = pluginConfig.getSchemaProblems({
            pkgName: 'fixtures',
            installPath: __dirname,
            schema: {
              type: 'object',
              properties: {
                foo: {
                  type: 'string'
                }
              }
            }
          }, 'foo');
          problems.should.be.empty;
        });
      });
    });
    describe('read()', function () {
      let pluginConfig;
      beforeEach(function () {
        pluginConfig = PluginConfig.getInstance('/tmp/');
        sandbox.spy(pluginConfig, 'validate');
      });
      it('should validate the extension', async function () {
        await pluginConfig.read();
        pluginConfig.validate.should.have.been.calledOnce;
      });
    });
    describe('readExtensionSchema()', function () {
      let pluginConfig;
      let extData;
      const extName = 'stuff';
      beforeEach(function () {
        extData = {
          installPath: 'fixtures',
          pkgName: 'some-pkg',
          schema: 'plugin.schema.js'
        };
        mocks['resolve-from'].returns(require.resolve('./fixtures/plugin.schema.js'));
        pluginConfig = PluginConfig.getInstance('/tmp/');
      });
      describe('when the extension data is missing `schema`', function () {
        it('should throw', function () {
          delete extData.schema;
          expect(() => pluginConfig.readExtensionSchema(extName, extData)).to.throw(TypeError, /why is this function being called/i);
        });
      });
      describe('when the extension schema has already been registered', function () {
        describe('when the schema is identical (presumably the same extension)', function () {
          it('should not throw', function () {
            pluginConfig.readExtensionSchema(extName, extData);
            expect(() => pluginConfig.readExtensionSchema(extName, extData)).not.to.throw();
          });
        });
        describe('when the schema differs (presumably a different extension)', function () {
          it('should throw', function () {
            pluginConfig.readExtensionSchema(extName, extData);
            mocks['resolve-from'].returns(require.resolve('./fixtures/driver.schema.js'));
            expect(() => pluginConfig.readExtensionSchema(extName, extData)).to.throw(/conflicts with an existing schema/i);
          });
        });
      });
      describe('when the extension schema has not yet been registered', function () {
        it('should resolve and load the extension schema file', function () {
          pluginConfig.readExtensionSchema(extName, extData);
          expect(mocks['resolve-from']).to.have.been.calledOnce;
        });
      });
    });
  });
});require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvZXh0ZW5zaW9uLWNvbmZpZy1zcGVjcy5qcyJdLCJuYW1lcyI6WyJleHBlY3QiLCJjaGFpIiwiZGVzY3JpYmUiLCJpdCIsIkRyaXZlckNvbmZpZyIsIm1vY2tzIiwic2FuZGJveCIsImJlZm9yZUVhY2giLCJzaW5vbiIsInN0dWIiLCJjYWxsc0Zha2UiLCJjd2QiLCJpZCIsInBhdGgiLCJqb2luIiwicmV3aXJlbW9jayIsInByb3h5IiwicmVxdWlyZSIsImRlZmF1bHQiLCJjcmVhdGVTYW5kYm94IiwiYWZ0ZXJFYWNoIiwicmVzdG9yZSIsImNvbmZpZyIsImdldEluc3RhbmNlIiwiZXh0ZW5zaW9uRGVzYyIsInZlcnNpb24iLCJhdXRvbWF0aW9uTmFtZSIsInNob3VsZCIsImVxdWFsIiwiZHJpdmVyQ29uZmlnIiwiZ2V0Q29uZmlnUHJvYmxlbXMiLCJ0aHJvdyIsImRlZXAiLCJpbmNsdWRlIiwiZXJyIiwidmFsIiwidW5kZWZpbmVkIiwicGxhdGZvcm1OYW1lcyIsImdldFNjaGVtYVByb2JsZW1zIiwic2NoZW1hIiwicHJvYmxlbXMiLCJpbnN0YWxsUGF0aCIsInBrZ05hbWUiLCJtYXRjaCIsIl9fZGlybmFtZSIsImJlIiwiZW1wdHkiLCJzcHkiLCJyZWFkIiwidmFsaWRhdGUiLCJoYXZlIiwiYmVlbiIsImNhbGxlZE9uY2UiLCJleHREYXRhIiwiZXh0TmFtZSIsInJldHVybnMiLCJyZXNvbHZlIiwicmVhZEV4dGVuc2lvblNjaGVtYSIsInRvIiwiVHlwZUVycm9yIiwibm90IiwiUGx1Z2luQ29uZmlnIiwicGx1Z2luQ29uZmlnIiwidHlwZSIsInByb3BlcnRpZXMiLCJmb28iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLE1BQU0sR0FBR0MsSUFBSSxDQUFDRCxNQUFwQjtBQUVBRSxRQUFRLENBQUMsaUJBQUQsRUFBb0IsWUFBWTtBQUN0Q0EsRUFBQUEsUUFBUSxDQUFDLDRCQUFELEVBQStCLFlBQVk7QUFD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QUFyRSxDQUF3RTNCLEtBQXhFO0FBQ0QsV0FIQyxDQUFGO0FBSUQsU0FMTyxDQUFSO0FBT0E3QixRQUFBQSxRQUFRLENBQUMsNERBQUQsRUFBK0QsWUFBWTtBQUNqRkMsVUFBQUEsRUFBRSxDQUFDLGNBQUQsRUFBaUIsWUFBWTtBQUM3QjJELFlBQUFBLFlBQVksQ0FBQ0wsbUJBQWIsQ0FBaUNILE9BQWpDLEVBQTBDRCxPQUExQztBQUNBaEQsWUFBQUEsS0FBSyxDQUFDLGNBQUQsQ0FBTCxDQUFzQmtELE9BQXRCLENBQThCdEMsT0FBTyxDQUFDdUMsT0FBUixDQUFnQiw2QkFBaEIsQ0FBOUI7QUFDQXhELFlBQUFBLE1BQU0sQ0FBQyxNQUFNOEQsWUFBWSxDQUFDTCxtQkFBYixDQUFpQ0gsT0FBakMsRUFBMENELE9BQTFDLENBQVAsQ0FBTixDQUFpRUssRUFBakUsQ0FBb0UzQixLQUFwRSxDQUEwRSxvQ0FBMUU7QUFDRCxXQUpDLENBQUY7QUFLRCxTQU5PLENBQVI7QUFPRCxPQWZPLENBQVI7QUFpQkE3QixNQUFBQSxRQUFRLENBQUMsdURBQUQsRUFBMEQsWUFBWTtBQUM1RUMsUUFBQUEsRUFBRSxDQUFDLG1EQUFELEVBQXNELFlBQVk7QUFDbEUyRCxVQUFBQSxZQUFZLENBQUNMLG1CQUFiLENBQWlDSCxPQUFqQyxFQUEwQ0QsT0FBMUM7QUFHQXJELFVBQUFBLE1BQU0sQ0FBQ0ssS0FBSyxDQUFDLGNBQUQsQ0FBTixDQUFOLENBQThCcUQsRUFBOUIsQ0FBaUNSLElBQWpDLENBQXNDQyxJQUF0QyxDQUEyQ0MsVUFBM0M7QUFDRCxTQUxDLENBQUY7QUFNRCxPQVBPLENBQVI7QUFRRCxLQTFETyxDQUFSO0FBMkRELEdBL01PLENBQVI7QUFnTkQsQ0FsZE8sQ0FBUiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCByZXdpcmVtb2NrIGZyb20gJ3Jld2lyZW1vY2svbm9kZSc7XG5pbXBvcnQgc2lub24gZnJvbSAnc2lub24nO1xuXG5jb25zdCBleHBlY3QgPSBjaGFpLmV4cGVjdDtcblxuZGVzY3JpYmUoJ0V4dGVuc2lvbkNvbmZpZycsIGZ1bmN0aW9uICgpIHtcbiAgZGVzY3JpYmUoJ2dldEdlbmVyaWNDb25maWdQcm9ibGVtcygpJywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdzaG91bGQgaGF2ZSBzb21lIHRlc3RzJyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEcml2ZXJDb25maWcnLCBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3R5cGVvZiBpbXBvcnQoJy4uL2xpYi9kcml2ZXItY29uZmlnJykuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBsZXQgRHJpdmVyQ29uZmlnO1xuICAgIGxldCBtb2NrcztcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnc2lub24nKS5TaW5vblNhbmRib3h9ICovXG4gICAgbGV0IHNhbmRib3g7XG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBtb2NrcyA9IHtcbiAgICAgICAgJ3Jlc29sdmUtZnJvbSc6IHNpbm9uLnN0dWIoKS5jYWxsc0Zha2UoKGN3ZCwgaWQpID0+IHBhdGguam9pbihjd2QsIGlkKSksXG4gICAgICB9O1xuXG4gICAgICBEcml2ZXJDb25maWcgPSByZXdpcmVtb2NrLnByb3h5KFxuICAgICAgICAoKSA9PiByZXF1aXJlKCcuLi9saWIvZHJpdmVyLWNvbmZpZycpLFxuICAgICAgICBtb2NrcyxcbiAgICAgICkuZGVmYXVsdDtcblxuICAgICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdleHRlbnNpb25EZXNjKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCgnc2hvdWxkIHJldHVybiB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGV4dGVuc2lvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gRHJpdmVyQ29uZmlnLmdldEluc3RhbmNlKCcvdG1wLycpO1xuICAgICAgICBjb25maWdcbiAgICAgICAgICAuZXh0ZW5zaW9uRGVzYygnZm9vJywge3ZlcnNpb246ICcxLjAnLCBhdXRvbWF0aW9uTmFtZTogJ2Jhcid9KVxuICAgICAgICAgIC5zaG91bGQuZXF1YWwoYGZvb0AxLjAgKGF1dG9tYXRpb25OYW1lICdiYXInKWApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2V0Q29uZmlnUHJvYmxlbXMoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1JldHVyblR5cGU8RHJpdmVyQ29uZmlnWydnZXRJbnN0YW5jZSddPn1cbiAgICAgICAqL1xuICAgICAgbGV0IGRyaXZlckNvbmZpZztcblxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyaXZlckNvbmZpZyA9IERyaXZlckNvbmZpZy5nZXRJbnN0YW5jZSgnL3RtcC8nKTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBwcm92aWRlZCBubyBhcmd1bWVudHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0KCdzaG91bGQgdGhyb3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICgoKSA9PiBkcml2ZXJDb25maWcuZ2V0Q29uZmlnUHJvYmxlbXMoKSkuc2hvdWxkLnRocm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCdwcm9wZXJ0eSBgcGxhdGZvcm1OYW1lc2AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGFuIG9iamVjdCB3aXRoIG5vIGBwbGF0Zm9ybU5hbWVzYCBwcm9wZXJ0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbiBhcnJheSB3aXRoIGFuIGFzc29jaWF0ZWQgcHJvYmxlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRyaXZlckNvbmZpZy5nZXRDb25maWdQcm9ibGVtcyh7fSwgJ2ZvbycpLnNob3VsZC5kZWVwLmluY2x1ZGUoe1xuICAgICAgICAgICAgICBlcnI6ICdNaXNzaW5nIG9yIGluY29ycmVjdCBzdXBwb3J0ZWQgcGxhdGZvcm1OYW1lcyBsaXN0LicsXG4gICAgICAgICAgICAgIHZhbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGFuIG9iamVjdCB3aXRoIGFuIGVtcHR5IGBwbGF0Zm9ybU5hbWVzYCBwcm9wZXJ0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbiBhcnJheSB3aXRoIGFuIGFzc29jaWF0ZWQgcHJvYmxlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRyaXZlckNvbmZpZ1xuICAgICAgICAgICAgICAuZ2V0Q29uZmlnUHJvYmxlbXMoe3BsYXRmb3JtTmFtZXM6IFtdfSwgJ2ZvbycpXG4gICAgICAgICAgICAgIC5zaG91bGQuZGVlcC5pbmNsdWRlKHtcbiAgICAgICAgICAgICAgICBlcnI6ICdFbXB0eSBwbGF0Zm9ybU5hbWVzIGxpc3QuJyxcbiAgICAgICAgICAgICAgICB2YWw6IFtdLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3doZW4gcHJvdmlkZWQgYW4gb2JqZWN0IHdpdGggYSBub24tYXJyYXkgYHBsYXRmb3JtTmFtZXNgIHByb3BlcnR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFuIGFycmF5IHdpdGggYW4gYXNzb2NpYXRlZCBwcm9ibGVtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZHJpdmVyQ29uZmlnXG4gICAgICAgICAgICAgIC5nZXRDb25maWdQcm9ibGVtcyh7cGxhdGZvcm1OYW1lczogJ2Zvbyd9LCAnZm9vJylcbiAgICAgICAgICAgICAgLnNob3VsZC5kZWVwLmluY2x1ZGUoe1xuICAgICAgICAgICAgICAgIGVycjogJ01pc3Npbmcgb3IgaW5jb3JyZWN0IHN1cHBvcnRlZCBwbGF0Zm9ybU5hbWVzIGxpc3QuJyxcbiAgICAgICAgICAgICAgICB2YWw6ICdmb28nLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3doZW4gcHJvdmlkZWQgYSBub24tZW1wdHkgYXJyYXkgY29udGFpbmluZyBhIG5vbi1zdHJpbmcgaXRlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbiBhcnJheSB3aXRoIGFuIGFzc29jaWF0ZWQgcHJvYmxlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRyaXZlckNvbmZpZ1xuICAgICAgICAgICAgICAuZ2V0Q29uZmlnUHJvYmxlbXMoe3BsYXRmb3JtTmFtZXM6IFsnYScsIDFdfSwgJ2ZvbycpXG4gICAgICAgICAgICAgIC5zaG91bGQuZGVlcC5pbmNsdWRlKHtcbiAgICAgICAgICAgICAgICBlcnI6ICdJbmNvcnJlY3RseSBmb3JtYXR0ZWQgcGxhdGZvcm1OYW1lLicsXG4gICAgICAgICAgICAgICAgdmFsOiAxLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3Byb3BlcnR5IGBhdXRvbWF0aW9uTmFtZWAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGFuIG9iamVjdCB3aXRoIGEgbWlzc2luZyBgYXV0b21hdGlvbk5hbWVgIHByb3BlcnR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFuIGFycmF5IHdpdGggYW4gYXNzb2NpYXRlZCBwcm9ibGVtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZHJpdmVyQ29uZmlnLmdldENvbmZpZ1Byb2JsZW1zKHt9LCAnZm9vJykuc2hvdWxkLmRlZXAuaW5jbHVkZSh7XG4gICAgICAgICAgICAgIGVycjogJ01pc3Npbmcgb3IgaW5jb3JyZWN0IGF1dG9tYXRpb25OYW1lJyxcbiAgICAgICAgICAgICAgdmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGEgY29uZmxpY3RpbmcgYXV0b21hdGlvbk5hbWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYW4gYXJyYXkgd2l0aCBhbiBhc3NvY2lhdGVkIHByb2JsZW0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkcml2ZXJDb25maWcuZ2V0Q29uZmlnUHJvYmxlbXMoe2F1dG9tYXRpb25OYW1lOiAnZm9vJ30sICdmb28nKTtcbiAgICAgICAgICAgIGRyaXZlckNvbmZpZ1xuICAgICAgICAgICAgICAuZ2V0Q29uZmlnUHJvYmxlbXMoe2F1dG9tYXRpb25OYW1lOiAnZm9vJ30sICdmb28nKVxuICAgICAgICAgICAgICAuc2hvdWxkLmRlZXAuaW5jbHVkZSh7XG4gICAgICAgICAgICAgICAgZXJyOiAnTXVsdGlwbGUgZHJpdmVycyBjbGFpbSBzdXBwb3J0IGZvciB0aGUgc2FtZSBhdXRvbWF0aW9uTmFtZScsXG4gICAgICAgICAgICAgICAgdmFsOiAnZm9vJyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2V0U2NoZW1hUHJvYmxlbXMoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1JldHVyblR5cGU8RHJpdmVyQ29uZmlnWydnZXRJbnN0YW5jZSddPn1cbiAgICAgICAqL1xuICAgICAgbGV0IGRyaXZlckNvbmZpZztcblxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyaXZlckNvbmZpZyA9IERyaXZlckNvbmZpZy5nZXRJbnN0YW5jZSgnL3RtcC8nKTtcbiAgICAgIH0pO1xuICAgICAgZGVzY3JpYmUoJ3doZW4gcHJvdmlkZWQgYW4gb2JqZWN0IHdpdGggYSBkZWZpbmVkIG5vbi1zdHJpbmcgYHNjaGVtYWAgcHJvcGVydHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFuIGFycmF5IHdpdGggYW4gYXNzb2NpYXRlZCBwcm9ibGVtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRyaXZlckNvbmZpZ1xuICAgICAgICAgICAgLmdldFNjaGVtYVByb2JsZW1zKHtzY2hlbWE6IFtdfSwgJ2ZvbycpXG4gICAgICAgICAgICAuc2hvdWxkLmRlZXAuaW5jbHVkZSh7XG4gICAgICAgICAgICAgIGVycjogJ0luY29ycmVjdGx5IGZvcm1hdHRlZCBzY2hlbWEgZmllbGQ7IG11c3QgYmUgYSBwYXRoIHRvIGEgc2NoZW1hIGZpbGUgb3IgYSBzY2hlbWEgb2JqZWN0LicsXG4gICAgICAgICAgICAgIHZhbDogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gcHJvdmlkZWQgYSBzdHJpbmcgYHNjaGVtYWAgcHJvcGVydHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlc2NyaWJlKCd3aGVuIHRoZSBwcm9wZXJ0eSBlbmRzIGluIGFuIHVuc3VwcG9ydGVkIGV4dGVuc2lvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbiBhcnJheSB3aXRoIGFuIGFzc29jaWF0ZWQgcHJvYmxlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRyaXZlckNvbmZpZ1xuICAgICAgICAgICAgICAuZ2V0U2NoZW1hUHJvYmxlbXMoe3NjaGVtYTogJ3NlbGVuaXVtLmphdmEnfSwgJ2ZvbycpXG4gICAgICAgICAgICAgIC5zaG91bGQuZGVlcC5pbmNsdWRlKHtcbiAgICAgICAgICAgICAgICBlcnI6ICdTY2hlbWEgZmlsZSBoYXMgdW5zdXBwb3J0ZWQgZXh0ZW5zaW9uLiBBbGxvd2VkOiAuanNvbiwgLmpzLCAuY2pzJyxcbiAgICAgICAgICAgICAgICB2YWw6ICdzZWxlbml1bS5qYXZhJyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCd3aGVuIHRoZSBwcm9wZXJ0eSBjb250YWlucyBhIHN1cHBvcnRlZCBleHRlbnNpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVzY3JpYmUoJ3doZW4gdGhlIHByb3BlcnR5IGFzIGEgcGF0aCBjYW5ub3QgYmUgZm91bmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbiBhcnJheSB3aXRoIGFuIGFzc29jaWF0ZWQgcHJvYmxlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJvYmxlbXMgPSBkcml2ZXJDb25maWcuZ2V0U2NoZW1hUHJvYmxlbXMoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaW5zdGFsbFBhdGg6ICcvdXNyL2Jpbi9kZXJwJyxcbiAgICAgICAgICAgICAgICAgIHBrZ05hbWU6ICdkb29wJyxcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogJ2hlcnAuanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZm9vJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJvYmxlbXNbMF0uZXJyLnNob3VsZC5tYXRjaCgvVW5hYmxlIHRvIHJlZ2lzdGVyIHNjaGVtYSBhdCBwYXRoIGhlcnBcXC5qc29uL2kpO1xuICAgICAgICAgICAgICAvLyBwcm9ibGVtcy5zaG91bGQuZGVlcC5pbmNsdWRlKHtcbiAgICAgICAgICAgICAgLy8gICBlcnI6IGBVbmFibGUgdG8gcmVnaXN0ZXIgc2NoZW1hIGF0IHBhdGggaGVycC5qc29uYCxcbiAgICAgICAgICAgICAgLy8gICB2YWw6ICdoZXJwLmpzb24nLFxuICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVzY3JpYmUoJ3doZW4gdGhlIHByb3BlcnR5IGFzIGEgcGF0aCBpcyBmb3VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFuIGVtcHR5IGFycmF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCBwcm9ibGVtcyA9IGRyaXZlckNvbmZpZy5nZXRTY2hlbWFQcm9ibGVtcyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBwa2dOYW1lOiAnZml4dHVyZXMnLCAvLyBqdXN0IGNvcnJlc3BvbmRzIHRvIGEgZGlyZWN0b3J5IG5hbWUgcmVsYXRpdmUgdG8gYGluc3RhbGxQYXRoYCBgKF9fZGlybmFtZSlgXG4gICAgICAgICAgICAgICAgICBpbnN0YWxsUGF0aDogX19kaXJuYW1lLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiAnZHJpdmVyLnNjaGVtYS5qcycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZm9vJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJvYmxlbXMuc2hvdWxkLmJlLmVtcHR5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgncmVhZCgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTxEcml2ZXJDb25maWdbJ2dldEluc3RhbmNlJ10+fVxuICAgICAgICovXG4gICAgICBsZXQgZHJpdmVyQ29uZmlnO1xuXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHJpdmVyQ29uZmlnID0gRHJpdmVyQ29uZmlnLmdldEluc3RhbmNlKCcvdG1wLycpO1xuICAgICAgICBzYW5kYm94LnNweShkcml2ZXJDb25maWcsICd2YWxpZGF0ZScpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdGhlIGV4dGVuc2lvbicsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXdhaXQgZHJpdmVyQ29uZmlnLnJlYWQoKTtcbiAgICAgICAgZHJpdmVyQ29uZmlnLnZhbGlkYXRlLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3JlYWRFeHRlbnNpb25TY2hlbWEoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1JldHVyblR5cGU8RHJpdmVyQ29uZmlnWydnZXRJbnN0YW5jZSddPn1cbiAgICAgICAqL1xuICAgICAgbGV0IGRyaXZlckNvbmZpZztcblxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL2xpYi9leHRlbnNpb24tY29uZmlnJykuRXh0RGF0YX0gKi9cbiAgICAgIGxldCBleHREYXRhO1xuXG4gICAgICBjb25zdCBleHROYW1lID0gJ3N0dWZmJztcblxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4dERhdGEgPSB7XG4gICAgICAgICAgaW5zdGFsbFBhdGg6ICdmaXh0dXJlcycsXG4gICAgICAgICAgcGtnTmFtZTogJ3NvbWUtcGtnJyxcbiAgICAgICAgICBzY2hlbWE6ICdkcml2ZXIuc2NoZW1hLmpzJyxcbiAgICAgICAgfTtcbiAgICAgICAgbW9ja3NbJ3Jlc29sdmUtZnJvbSddLnJldHVybnMoXG4gICAgICAgICAgcmVxdWlyZS5yZXNvbHZlKCcuL2ZpeHR1cmVzL2RyaXZlci5zY2hlbWEuanMnKSxcbiAgICAgICAgKTtcbiAgICAgICAgZHJpdmVyQ29uZmlnID0gRHJpdmVyQ29uZmlnLmdldEluc3RhbmNlKCcvdG1wLycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIHRoZSBleHRlbnNpb24gZGF0YSBpcyBtaXNzaW5nIGBzY2hlbWFgJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHRocm93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlbGV0ZSBleHREYXRhLnNjaGVtYTtcbiAgICAgICAgICBleHBlY3QoKCkgPT5cbiAgICAgICAgICAgIGRyaXZlckNvbmZpZy5yZWFkRXh0ZW5zaW9uU2NoZW1hKGV4dE5hbWUsIGV4dERhdGEpLFxuICAgICAgICAgICkudG8udGhyb3coVHlwZUVycm9yLCAvd2h5IGlzIHRoaXMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkL2kpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiB0aGUgZXh0ZW5zaW9uIHNjaGVtYSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgKHdpdGggdGhlIHNhbWUgc2NoZW1hKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCBub3QgdGhyb3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJpdmVyQ29uZmlnLnJlYWRFeHRlbnNpb25TY2hlbWEoZXh0TmFtZSwgZXh0RGF0YSk7XG4gICAgICAgICAgZXhwZWN0KCgpID0+IGRyaXZlckNvbmZpZy5yZWFkRXh0ZW5zaW9uU2NoZW1hKGV4dE5hbWUsIGV4dERhdGEpKS5ub3QudG8udGhyb3coKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gdGhlIGV4dGVuc2lvbiBzY2hlbWEgaGFzIG5vdCB5ZXQgYmVlbiByZWdpc3RlcmVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJlc29sdmUgYW5kIGxvYWQgdGhlIGV4dGVuc2lvbiBzY2hlbWEgZmlsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkcml2ZXJDb25maWcucmVhZEV4dGVuc2lvblNjaGVtYSAoZXh0TmFtZSwgZXh0RGF0YSk7XG5cbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgc2NoZW1hIHJlZ2lzdHJhdGlvbiBjYWNoZSBkaXJlY3RseSwgc28gdGhpcyBpcyBhcyBjbG9zZSBhcyB3ZSBjYW4gZ2V0LlxuICAgICAgICAgIGV4cGVjdChtb2Nrc1sncmVzb2x2ZS1mcm9tJ10pLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGx1Z2luQ29uZmlnJywgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCcuLi9saWIvcGx1Z2luLWNvbmZpZycpLmRlZmF1bHR9XG4gICAgICovXG4gICAgbGV0IFBsdWdpbkNvbmZpZztcbiAgICBsZXQgbW9ja3M7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3Npbm9uJykuU2lub25TYW5kYm94fSAqL1xuICAgIGxldCBzYW5kYm94O1xuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbW9ja3MgPSB7XG4gICAgICAgICdyZXNvbHZlLWZyb20nOiBzaW5vbi5zdHViKCkuY2FsbHNGYWtlKChjd2QsIGlkKSA9PiBwYXRoLmpvaW4oY3dkLCBpZCkpLFxuICAgICAgfTtcblxuICAgICAgUGx1Z2luQ29uZmlnID0gcmV3aXJlbW9jay5wcm94eShcbiAgICAgICAgKCkgPT4gcmVxdWlyZSgnLi4vbGliL3BsdWdpbi1jb25maWcnKSxcbiAgICAgICAgbW9ja3MsXG4gICAgICApLmRlZmF1bHQ7XG5cbiAgICAgIHNhbmRib3ggPSBzaW5vbi5jcmVhdGVTYW5kYm94KCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZXh0ZW5zaW9uRGVzYygpJywgZnVuY3Rpb24gKCkge1xuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBleHRlbnNpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IFBsdWdpbkNvbmZpZy5nZXRJbnN0YW5jZSgnL3RtcC8nKTtcbiAgICAgICAgY29uZmlnXG4gICAgICAgICAgLmV4dGVuc2lvbkRlc2MoJ2ZvbycsIHt2ZXJzaW9uOiAnMS4wJ30pXG4gICAgICAgICAgLnNob3VsZC5lcXVhbChgZm9vQDEuMGApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2V0Q29uZmlnUHJvYmxlbXMoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1JldHVyblR5cGU8UGx1Z2luQ29uZmlnWydnZXRJbnN0YW5jZSddPn1cbiAgICAgICAqL1xuICAgICAgbGV0IHBsdWdpbkNvbmZpZztcblxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBsdWdpbkNvbmZpZyA9IFBsdWdpbkNvbmZpZy5nZXRJbnN0YW5jZSgnL3RtcC8nKTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBwcm92aWRlZCBubyBhcmd1bWVudHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0KCdzaG91bGQgbm90IHRocm93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAoKCkgPT4gcGx1Z2luQ29uZmlnLmdldENvbmZpZ1Byb2JsZW1zKCkpLnNob3VsZC5ub3QudGhyb3coKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZXRTY2hlbWFQcm9ibGVtcygpJywgZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTxQbHVnaW5Db25maWdbJ2dldEluc3RhbmNlJ10+fVxuICAgICAgICovXG4gICAgICBsZXQgcGx1Z2luQ29uZmlnO1xuXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGx1Z2luQ29uZmlnID0gUGx1Z2luQ29uZmlnLmdldEluc3RhbmNlKCcvdG1wLycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGFuIG9iamVjdCB3aXRoIGEgZGVmaW5lZCBgc2NoZW1hYCBwcm9wZXJ0eSBvZiB1bnN1cHBvcnRlZCB0eXBlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbiBhcnJheSB3aXRoIGFuIGFzc29jaWF0ZWQgcHJvYmxlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwbHVnaW5Db25maWdcbiAgICAgICAgICAgIC5nZXRTY2hlbWFQcm9ibGVtcyh7c2NoZW1hOiBbXX0sICdmb28nKVxuICAgICAgICAgICAgLnNob3VsZC5kZWVwLmluY2x1ZGUoe1xuICAgICAgICAgICAgICBlcnI6ICdJbmNvcnJlY3RseSBmb3JtYXR0ZWQgc2NoZW1hIGZpZWxkOyBtdXN0IGJlIGEgcGF0aCB0byBhIHNjaGVtYSBmaWxlIG9yIGEgc2NoZW1hIG9iamVjdC4nLFxuICAgICAgICAgICAgICB2YWw6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGEgc3RyaW5nIGBzY2hlbWFgIHByb3BlcnR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXNjcmliZSgnd2hlbiB0aGUgcHJvcGVydHkgZW5kcyBpbiBhbiB1bnN1cHBvcnRlZCBleHRlbnNpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYW4gYXJyYXkgd2l0aCBhbiBhc3NvY2lhdGVkIHByb2JsZW0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwbHVnaW5Db25maWdcbiAgICAgICAgICAgICAgLmdldFNjaGVtYVByb2JsZW1zKHtzY2hlbWE6ICdzZWxlbml1bS5qYXZhJ30sICdmb28nKVxuICAgICAgICAgICAgICAuc2hvdWxkLmRlZXAuaW5jbHVkZSh7XG4gICAgICAgICAgICAgICAgZXJyOiAnU2NoZW1hIGZpbGUgaGFzIHVuc3VwcG9ydGVkIGV4dGVuc2lvbi4gQWxsb3dlZDogLmpzb24sIC5qcywgLmNqcycsXG4gICAgICAgICAgICAgICAgdmFsOiAnc2VsZW5pdW0uamF2YScsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnd2hlbiB0aGUgcHJvcGVydHkgY29udGFpbnMgYSBzdXBwb3J0ZWQgZXh0ZW5zaW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlc2NyaWJlKCd3aGVuIHRoZSBwcm9wZXJ0eSBhcyBhIHBhdGggY2Fubm90IGJlIGZvdW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYW4gYXJyYXkgd2l0aCBhbiBhc3NvY2lhdGVkIHByb2JsZW0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByb2JsZW1zID0gcGx1Z2luQ29uZmlnLmdldFNjaGVtYVByb2JsZW1zKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbGxQYXRoOiAnL3Vzci9iaW4vZGVycCcsXG4gICAgICAgICAgICAgICAgICBwa2dOYW1lOiAnZG9vcCcsXG4gICAgICAgICAgICAgICAgICBzY2hlbWE6ICdoZXJwLmpzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2ZvbycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByb2JsZW1zWzBdLmVyci5zaG91bGQubWF0Y2goL1VuYWJsZSB0byByZWdpc3RlciBzY2hlbWEgYXQgcGF0aCBoZXJwXFwuanNvbi9pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVzY3JpYmUoJ3doZW4gdGhlIHByb3BlcnR5IGFzIGEgcGF0aCBpcyBmb3VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFuIGVtcHR5IGFycmF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCBwcm9ibGVtcyA9IHBsdWdpbkNvbmZpZy5nZXRTY2hlbWFQcm9ibGVtcyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBwa2dOYW1lOiAnZml4dHVyZXMnLCAvLyBqdXN0IGNvcnJlc3BvbmRzIHRvIGEgZGlyZWN0b3J5IG5hbWUgcmVsYXRpdmUgdG8gYGluc3RhbGxQYXRoYCBgKF9fZGlybmFtZSlgXG4gICAgICAgICAgICAgICAgICBpbnN0YWxsUGF0aDogX19kaXJuYW1lLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiAncGx1Z2luLnNjaGVtYS5qcycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZm9vJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJvYmxlbXMuc2hvdWxkLmJlLmVtcHR5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIHByb3ZpZGVkIGFuIG9iamVjdCBgc2NoZW1hYCBwcm9wZXJ0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYW4gZW1wdHkgYXJyYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgcHJvYmxlbXMgPSBwbHVnaW5Db25maWcuZ2V0U2NoZW1hUHJvYmxlbXMoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBrZ05hbWU6ICdmaXh0dXJlcycsIC8vIGp1c3QgY29ycmVzcG9uZHMgdG8gYSBkaXJlY3RvcnkgbmFtZSByZWxhdGl2ZSB0byBgaW5zdGFsbFBhdGhgIGAoX19kaXJuYW1lKWBcbiAgICAgICAgICAgICAgaW5zdGFsbFBhdGg6IF9fZGlybmFtZSxcbiAgICAgICAgICAgICAgc2NoZW1hOiB7dHlwZTogJ29iamVjdCcsIHByb3BlcnRpZXM6IHtmb286IHt0eXBlOiAnc3RyaW5nJ319fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZm9vJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHByb2JsZW1zLnNob3VsZC5iZS5lbXB0eTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdyZWFkKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPFBsdWdpbkNvbmZpZ1snZ2V0SW5zdGFuY2UnXT59XG4gICAgICAgKi9cbiAgICAgIGxldCBwbHVnaW5Db25maWc7XG5cbiAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBwbHVnaW5Db25maWcgPSBQbHVnaW5Db25maWcuZ2V0SW5zdGFuY2UoJy90bXAvJyk7XG4gICAgICAgIHNhbmRib3guc3B5KHBsdWdpbkNvbmZpZywgJ3ZhbGlkYXRlJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB0aGUgZXh0ZW5zaW9uJywgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBhd2FpdCBwbHVnaW5Db25maWcucmVhZCgpO1xuICAgICAgICBwbHVnaW5Db25maWcudmFsaWRhdGUuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgncmVhZEV4dGVuc2lvblNjaGVtYSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTxQbHVnaW5Db25maWdbJ2dldEluc3RhbmNlJ10+fVxuICAgICAgICovXG4gICAgICBsZXQgcGx1Z2luQ29uZmlnO1xuXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vbGliL2V4dGVuc2lvbi1jb25maWcnKS5FeHREYXRhfSAqL1xuICAgICAgbGV0IGV4dERhdGE7XG5cbiAgICAgIGNvbnN0IGV4dE5hbWUgPSAnc3R1ZmYnO1xuXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXh0RGF0YSA9IHtcbiAgICAgICAgICBpbnN0YWxsUGF0aDogJ2ZpeHR1cmVzJyxcbiAgICAgICAgICBwa2dOYW1lOiAnc29tZS1wa2cnLFxuICAgICAgICAgIHNjaGVtYTogJ3BsdWdpbi5zY2hlbWEuanMnLFxuICAgICAgICB9O1xuICAgICAgICBtb2Nrc1sncmVzb2x2ZS1mcm9tJ10ucmV0dXJucyhcbiAgICAgICAgICByZXF1aXJlLnJlc29sdmUoJy4vZml4dHVyZXMvcGx1Z2luLnNjaGVtYS5qcycpLFxuICAgICAgICApO1xuICAgICAgICBwbHVnaW5Db25maWcgPSBQbHVnaW5Db25maWcuZ2V0SW5zdGFuY2UoJy90bXAvJyk7XG5cbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiB0aGUgZXh0ZW5zaW9uIGRhdGEgaXMgbWlzc2luZyBgc2NoZW1hYCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCB0aHJvdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWxldGUgZXh0RGF0YS5zY2hlbWE7XG4gICAgICAgICAgZXhwZWN0KCgpID0+XG4gICAgICAgICAgICBwbHVnaW5Db25maWcucmVhZEV4dGVuc2lvblNjaGVtYShleHROYW1lLCBleHREYXRhKSxcbiAgICAgICAgICApLnRvLnRocm93KFR5cGVFcnJvciwgL3doeSBpcyB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZC9pKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gdGhlIGV4dGVuc2lvbiBzY2hlbWEgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXNjcmliZSgnd2hlbiB0aGUgc2NoZW1hIGlzIGlkZW50aWNhbCAocHJlc3VtYWJseSB0aGUgc2FtZSBleHRlbnNpb24pJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGl0KCdzaG91bGQgbm90IHRocm93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGx1Z2luQ29uZmlnLnJlYWRFeHRlbnNpb25TY2hlbWEoZXh0TmFtZSwgZXh0RGF0YSk7XG4gICAgICAgICAgICBleHBlY3QoKCkgPT4gcGx1Z2luQ29uZmlnLnJlYWRFeHRlbnNpb25TY2hlbWEoZXh0TmFtZSwgZXh0RGF0YSkpLm5vdC50by50aHJvdygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnd2hlbiB0aGUgc2NoZW1hIGRpZmZlcnMgKHByZXN1bWFibHkgYSBkaWZmZXJlbnQgZXh0ZW5zaW9uKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpdCgnc2hvdWxkIHRocm93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGx1Z2luQ29uZmlnLnJlYWRFeHRlbnNpb25TY2hlbWEoZXh0TmFtZSwgZXh0RGF0YSk7XG4gICAgICAgICAgICBtb2Nrc1sncmVzb2x2ZS1mcm9tJ10ucmV0dXJucyhyZXF1aXJlLnJlc29sdmUoJy4vZml4dHVyZXMvZHJpdmVyLnNjaGVtYS5qcycpKTtcbiAgICAgICAgICAgIGV4cGVjdCgoKSA9PiBwbHVnaW5Db25maWcucmVhZEV4dGVuc2lvblNjaGVtYShleHROYW1lLCBleHREYXRhKSkudG8udGhyb3coL2NvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIHNjaGVtYS9pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gdGhlIGV4dGVuc2lvbiBzY2hlbWEgaGFzIG5vdCB5ZXQgYmVlbiByZWdpc3RlcmVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJlc29sdmUgYW5kIGxvYWQgdGhlIGV4dGVuc2lvbiBzY2hlbWEgZmlsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwbHVnaW5Db25maWcucmVhZEV4dGVuc2lvblNjaGVtYShleHROYW1lLCBleHREYXRhKTtcblxuICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZSBzY2hlbWEgcmVnaXN0cmF0aW9uIGNhY2hlIGRpcmVjdGx5LCBzbyB0aGlzIGlzIGFzIGNsb3NlIGFzIHdlIGNhbiBnZXQuXG4gICAgICAgICAgZXhwZWN0KG1vY2tzWydyZXNvbHZlLWZyb20nXSkudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwiZmlsZSI6InRlc3QvZXh0ZW5zaW9uLWNvbmZpZy1zcGVjcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
