"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fs = exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _fs2 = _interopRequireDefault(require("fs"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _ncp = _interopRequireDefault(require("ncp"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _mv = _interopRequireDefault(require("mv"));

var _which = _interopRequireDefault(require("which"));

var _glob = _interopRequireDefault(require("glob"));

var _crypto = _interopRequireDefault(require("crypto"));

var _klaw = _interopRequireDefault(require("klaw"));

var _sanitizeFilename = _interopRequireDefault(require("sanitize-filename"));

var _findRoot = _interopRequireDefault(require("find-root"));

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var _timing = _interopRequireDefault(require("./timing"));

const mkdirAsync = _bluebird.default.promisify(_fs2.default.mkdir);

const ncpAsync = _bluebird.default.promisify(_ncp.default);

const findRootCached = _lodash.default.memoize(_findRoot.default);

const fs = {
  async hasAccess(path) {
    try {
      await this.access(path, _fs2.default.R_OK);
    } catch (err) {
      return false;
    }

    return true;
  },

  exists(path) {
    return this.hasAccess(path);
  },

  rimraf: _bluebird.default.promisify(_rimraf.default),
  rimrafSync: _rimraf.default.sync.bind(_rimraf.default),

  async mkdir(...args) {
    try {
      return await mkdirAsync(...args);
    } catch (err) {
      if (err && err.code !== 'EEXIST') {
        throw err;
      }
    }
  },

  async copyFile(source, destination, ...otherArgs) {
    if (!(await this.hasAccess(source))) {
      throw new Error(`The file at '${source}' does not exist or is not accessible`);
    }

    return await ncpAsync(source, destination, ...otherArgs);
  },

  async md5(filePath) {
    return await this.hash(filePath, 'md5');
  },

  mv: _bluebird.default.promisify(_mv.default),
  which: _bluebird.default.promisify(_which.default),
  glob: _bluebird.default.promisify(_glob.default),
  sanitizeName: _sanitizeFilename.default,

  async hash(filePath, algorithm = 'sha1') {
    return await new _bluebird.default((resolve, reject) => {
      const fileHash = _crypto.default.createHash(algorithm);

      const readStream = _fs2.default.createReadStream(filePath);

      readStream.on('error', e => reject(new Error(`Cannot calculate ${algorithm} hash for '${filePath}'. Original error: ${e.message}`)));
      readStream.on('data', chunk => fileHash.update(chunk));
      readStream.on('end', () => resolve(fileHash.digest('hex')));
    });
  },

  async walkDir(dir, recursive, callback) {
    let isValidRoot = false;
    let errMsg = null;

    try {
      isValidRoot = (await fs.stat(dir)).isDirectory();
    } catch (e) {
      errMsg = e.message;
    }

    if (!isValidRoot) {
      throw Error(`'${dir}' is not a valid root directory` + (errMsg ? `. Original error: ${errMsg}` : ''));
    }

    let walker;
    let fileCount = 0;
    let directoryCount = 0;
    const timer = new _timing.default().start();
    return await new _bluebird.default(function (resolve, reject) {
      let lastFileProcessed = _bluebird.default.resolve();

      walker = (0, _klaw.default)(dir, {
        depthLimit: recursive ? -1 : 0
      });
      walker.on('data', function (item) {
        walker.pause();

        if (!item.stats.isDirectory()) {
          fileCount++;
        } else {
          directoryCount++;
        }

        lastFileProcessed = _bluebird.default.try(async () => await callback(item.path, item.stats.isDirectory())).then(function (done = false) {
          if (done) {
            resolve(item.path);
          } else {
            walker.resume();
          }
        }).catch(reject);
      }).on('error', function (err, item) {
        _logger.default.warn(`Got an error while walking '${item.path}': ${err.message}`);

        if (err.code === 'ENOENT') {
          _logger.default.warn('All files may not have been accessed');

          reject(err);
        }
      }).on('end', function () {
        lastFileProcessed.then(resolve).catch(function (err) {
          _logger.default.warn(`Unexpected error: ${err.message}`);

          reject(err);
        });
      });
    }).finally(function () {
      _logger.default.debug(`Traversed ${(0, _util.pluralize)('directory', directoryCount, true)} ` + `and ${(0, _util.pluralize)('file', fileCount, true)} ` + `in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);

      if (walker) {
        walker.destroy();
      }
    });
  },

  readPackageJsonFrom(dir) {
    const root = fs.findRoot(dir);

    try {
      return JSON.parse(_fs2.default.readFileSync(_path.default.join(root, 'package.json'), 'utf8'));
    } catch (err) {
      err.message = `Failed to read a \`package.json\` from dir \`${dir}\`:\n\n${err.message}`;
      throw err;
    }
  },

  findRoot(dir) {
    if (!dir || !_path.default.isAbsolute(dir)) {
      throw new TypeError('`findRoot()` must be provided a non-empty, absolute path');
    }

    const result = findRootCached(dir);

    if (!result) {
      throw new Error(`\`findRoot()\` could not find \`package.json\` from ${dir}`);
    }

    return result;
  }

};
exports.fs = fs;
const simples = ['open', 'close', 'access', 'readFile', 'writeFile', 'write', 'read', 'readlink', 'chmod', 'unlink', 'readdir', 'stat', 'rename', 'lstat', 'appendFile', 'realpath', 'symlink'];

for (const s of simples) {
  fs[s] = _bluebird.default.promisify(_fs2.default[s]);
}

const syncFunctions = ['createReadStream', 'createWriteStream'];

for (const s of syncFunctions) {
  fs[s] = _fs2.default[s];
}

const constants = ['F_OK', 'R_OK', 'W_OK', 'X_OK', 'constants'];

for (const c of constants) {
  fs[c] = _fs2.default[c];
}

var _default = fs;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9mcy5qcyJdLCJuYW1lcyI6WyJta2RpckFzeW5jIiwiQiIsInByb21pc2lmeSIsIl9mcyIsIm1rZGlyIiwibmNwQXN5bmMiLCJuY3AiLCJmaW5kUm9vdENhY2hlZCIsIl8iLCJtZW1vaXplIiwiZmluZFJvb3QiLCJmcyIsImhhc0FjY2VzcyIsInBhdGgiLCJhY2Nlc3MiLCJSX09LIiwiZXJyIiwiZXhpc3RzIiwicmltcmFmIiwicmltcmFmU3luYyIsInN5bmMiLCJiaW5kIiwiYXJncyIsImNvZGUiLCJjb3B5RmlsZSIsInNvdXJjZSIsImRlc3RpbmF0aW9uIiwib3RoZXJBcmdzIiwiRXJyb3IiLCJtZDUiLCJmaWxlUGF0aCIsImhhc2giLCJtdiIsIndoaWNoIiwiZ2xvYiIsInNhbml0aXplTmFtZSIsInNhbml0aXplIiwiYWxnb3JpdGhtIiwicmVzb2x2ZSIsInJlamVjdCIsImZpbGVIYXNoIiwiY3J5cHRvIiwiY3JlYXRlSGFzaCIsInJlYWRTdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwib24iLCJlIiwibWVzc2FnZSIsImNodW5rIiwidXBkYXRlIiwiZGlnZXN0Iiwid2Fsa0RpciIsImRpciIsInJlY3Vyc2l2ZSIsImNhbGxiYWNrIiwiaXNWYWxpZFJvb3QiLCJlcnJNc2ciLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJ3YWxrZXIiLCJmaWxlQ291bnQiLCJkaXJlY3RvcnlDb3VudCIsInRpbWVyIiwiVGltZXIiLCJzdGFydCIsImxhc3RGaWxlUHJvY2Vzc2VkIiwiZGVwdGhMaW1pdCIsIml0ZW0iLCJwYXVzZSIsInN0YXRzIiwidHJ5IiwidGhlbiIsImRvbmUiLCJyZXN1bWUiLCJjYXRjaCIsImxvZyIsIndhcm4iLCJmaW5hbGx5IiwiZGVidWciLCJnZXREdXJhdGlvbiIsImFzTWlsbGlTZWNvbmRzIiwidG9GaXhlZCIsImRlc3Ryb3kiLCJyZWFkUGFja2FnZUpzb25Gcm9tIiwicm9vdCIsIkpTT04iLCJwYXJzZSIsInJlYWRGaWxlU3luYyIsImpvaW4iLCJpc0Fic29sdXRlIiwiVHlwZUVycm9yIiwicmVzdWx0Iiwic2ltcGxlcyIsInMiLCJzeW5jRnVuY3Rpb25zIiwiY29uc3RhbnRzIiwiYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxVQUFVLEdBQUdDLGtCQUFFQyxTQUFGLENBQVlDLGFBQUlDLEtBQWhCLENBQW5COztBQUNBLE1BQU1DLFFBQVEsR0FBR0osa0JBQUVDLFNBQUYsQ0FBWUksWUFBWixDQUFqQjs7QUFDQSxNQUFNQyxjQUFjLEdBQUdDLGdCQUFFQyxPQUFGLENBQVVDLGlCQUFWLENBQXZCOztBQUVBLE1BQU1DLEVBQUUsR0FBRztBQUNULFFBQU1DLFNBQU4sQ0FBaUJDLElBQWpCLEVBQXVCO0FBQ3JCLFFBQUk7QUFDRixZQUFNLEtBQUtDLE1BQUwsQ0FBWUQsSUFBWixFQUFrQlYsYUFBSVksSUFBdEIsQ0FBTjtBQUNELEtBRkQsQ0FFRSxPQUFPQyxHQUFQLEVBQVk7QUFDWixhQUFPLEtBQVA7QUFDRDs7QUFDRCxXQUFPLElBQVA7QUFDRCxHQVJROztBQVNUQyxFQUFBQSxNQUFNLENBQUVKLElBQUYsRUFBUTtBQUFFLFdBQU8sS0FBS0QsU0FBTCxDQUFlQyxJQUFmLENBQVA7QUFBOEIsR0FUckM7O0FBVVRLLEVBQUFBLE1BQU0sRUFBRWpCLGtCQUFFQyxTQUFGLENBQVlnQixlQUFaLENBVkM7QUFXVEMsRUFBQUEsVUFBVSxFQUFFRCxnQkFBT0UsSUFBUCxDQUFZQyxJQUFaLENBQWlCSCxlQUFqQixDQVhIOztBQVlULFFBQU1kLEtBQU4sQ0FBYSxHQUFHa0IsSUFBaEIsRUFBc0I7QUFDcEIsUUFBSTtBQUNGLGFBQU8sTUFBTXRCLFVBQVUsQ0FBQyxHQUFHc0IsSUFBSixDQUF2QjtBQUNELEtBRkQsQ0FFRSxPQUFPTixHQUFQLEVBQVk7QUFD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QStCO0FBQzdCbkYsRUFBQUEsRUFBRSxDQUFDa0YsQ0FBRCxDQUFGLEdBQVExRixhQUFJMEYsQ0FBSixDQUFSO0FBQ0Q7O0FBR0QsTUFBTUUsU0FBUyxHQUFHLENBQ2hCLE1BRGdCLEVBQ1IsTUFEUSxFQUNBLE1BREEsRUFDUSxNQURSLEVBQ2dCLFdBRGhCLENBQWxCOztBQUdBLEtBQUssTUFBTUMsQ0FBWCxJQUFnQkQsU0FBaEIsRUFBMkI7QUFDekJwRixFQUFBQSxFQUFFLENBQUNxRixDQUFELENBQUYsR0FBUTdGLGFBQUk2RixDQUFKLENBQVI7QUFDRDs7ZUFHY3JGLEUiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBqc2hpbnQgaWdub3JlOiBzdGFydFxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF9mcyBmcm9tICdmcyc7XG5pbXBvcnQgcmltcmFmIGZyb20gJ3JpbXJhZic7XG5pbXBvcnQgbmNwIGZyb20gJ25jcCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgbXYgZnJvbSAnbXYnO1xuaW1wb3J0IHdoaWNoIGZyb20gJ3doaWNoJztcbmltcG9ydCBnbG9iIGZyb20gJ2dsb2InO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IGtsYXcgZnJvbSAna2xhdyc7XG5pbXBvcnQgc2FuaXRpemUgZnJvbSAnc2FuaXRpemUtZmlsZW5hbWUnO1xuaW1wb3J0IGZpbmRSb290IGZyb20gJ2ZpbmQtcm9vdCc7XG5pbXBvcnQgeyBwbHVyYWxpemUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi90aW1pbmcnO1xuXG5jb25zdCBta2RpckFzeW5jID0gQi5wcm9taXNpZnkoX2ZzLm1rZGlyKTtcbmNvbnN0IG5jcEFzeW5jID0gQi5wcm9taXNpZnkobmNwKTtcbmNvbnN0IGZpbmRSb290Q2FjaGVkID0gXy5tZW1vaXplKGZpbmRSb290KTtcblxuY29uc3QgZnMgPSB7XG4gIGFzeW5jIGhhc0FjY2VzcyAocGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFjY2VzcyhwYXRoLCBfZnMuUl9PSyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBleGlzdHMgKHBhdGgpIHsgcmV0dXJuIHRoaXMuaGFzQWNjZXNzKHBhdGgpOyB9LFxuICByaW1yYWY6IEIucHJvbWlzaWZ5KHJpbXJhZiksXG4gIHJpbXJhZlN5bmM6IHJpbXJhZi5zeW5jLmJpbmQocmltcmFmKSxcbiAgYXN5bmMgbWtkaXIgKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IG1rZGlyQXN5bmMoLi4uYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRUVYSVNUJykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhc3luYyBjb3B5RmlsZSAoc291cmNlLCBkZXN0aW5hdGlvbiwgLi4ub3RoZXJBcmdzKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmhhc0FjY2Vzcyhzb3VyY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke3NvdXJjZX0nIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhY2Nlc3NpYmxlYCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuY3BBc3luYyhzb3VyY2UsIGRlc3RpbmF0aW9uLCAuLi5vdGhlckFyZ3MpO1xuICB9LFxuICBhc3luYyBtZDUgKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFzaChmaWxlUGF0aCwgJ21kNScpO1xuICB9LFxuICBtdjogQi5wcm9taXNpZnkobXYpLFxuICB3aGljaDogQi5wcm9taXNpZnkod2hpY2gpLFxuICBnbG9iOiBCLnByb21pc2lmeShnbG9iKSxcbiAgc2FuaXRpemVOYW1lOiBzYW5pdGl6ZSxcbiAgYXN5bmMgaGFzaCAoZmlsZVBhdGgsIGFsZ29yaXRobSA9ICdzaGExJykge1xuICAgIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBmaWxlSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgICBjb25zdCByZWFkU3RyZWFtID0gX2ZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgcmVhZFN0cmVhbS5vbignZXJyb3InLCAoZSkgPT4gcmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoYENhbm5vdCBjYWxjdWxhdGUgJHthbGdvcml0aG19IGhhc2ggZm9yICcke2ZpbGVQYXRofScuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKSkpO1xuICAgICAgcmVhZFN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4gZmlsZUhhc2gudXBkYXRlKGNodW5rKSk7XG4gICAgICByZWFkU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKGZpbGVIYXNoLmRpZ2VzdCgnaGV4JykpKTtcbiAgICB9KTtcbiAgfSxcbiAgLyoqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBkdXJpbmcgdGhlIGRpcmVjdG9yeSB3YWxraW5nXG4gICAqIEBuYW1lIFdhbGtEaXJDYWxsYmFja1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1QYXRoIFRoZSBwYXRoIG9mIHRoZSBmaWxlIG9yIGZvbGRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlyZWN0b3J5IFNob3dzIGlmIGl0IGlzIGEgZGlyZWN0b3J5IG9yIGEgZmlsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSByZXR1cm4gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdG9wIHdhbGtpbmdcbiAgKi9cblxuICAvKipcbiAgICogV2Fsa3MgYSBkaXJlY3RvcnkgZ2l2ZW4gYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzIGdpdmVuLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdpdGggYSBwYXRoIGpvaW5lZCB3aXRoIHRoZSBkaXIgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgRGlyZWN0b3J5IHBhdGggd2hlcmUgd2Ugd2lsbCBzdGFydCB3YWxraW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFNldCBpdCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGNvbnRpbnVlIHdhbGtpbmcgc3ViIGRpcmVjdG9yaWVzXG4gICAqIEBwYXJhbSB7V2Fsa0RpckNhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gYSBuZXcgcGF0aCBpcyBmb3VuZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGBkaXJgIHBhcmFtZXRlciBjb250YWlucyBhIHBhdGggdG8gYW4gaW52YWxpZCBmb2xkZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gcmV0dXJucyB0aGUgZm91bmQgcGF0aCBvciBudWxsIGlmIHRoZSBpdGVtIHdhcyBub3QgZm91bmRcbiAgICovXG4gIGFzeW5jIHdhbGtEaXIgKGRpciwgcmVjdXJzaXZlLCBjYWxsYmFjaykgeyAvL2VzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gICAgbGV0IGlzVmFsaWRSb290ID0gZmFsc2U7XG4gICAgbGV0IGVyck1zZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGlzVmFsaWRSb290ID0gKGF3YWl0IGZzLnN0YXQoZGlyKSkuaXNEaXJlY3RvcnkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJNc2cgPSBlLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFJvb3QpIHtcbiAgICAgIHRocm93IEVycm9yKGAnJHtkaXJ9JyBpcyBub3QgYSB2YWxpZCByb290IGRpcmVjdG9yeWAgKyAoZXJyTXNnID8gYC4gT3JpZ2luYWwgZXJyb3I6ICR7ZXJyTXNnfWAgOiAnJykpO1xuICAgIH1cblxuICAgIGxldCB3YWxrZXI7XG4gICAgbGV0IGZpbGVDb3VudCA9IDA7XG4gICAgbGV0IGRpcmVjdG9yeUNvdW50ID0gMDtcbiAgICBjb25zdCB0aW1lciA9IG5ldyBUaW1lcigpLnN0YXJ0KCk7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBCKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxldCBsYXN0RmlsZVByb2Nlc3NlZCA9IEIucmVzb2x2ZSgpO1xuICAgICAgd2Fsa2VyID0ga2xhdyhkaXIsIHtcbiAgICAgICAgZGVwdGhMaW1pdDogcmVjdXJzaXZlID8gLTEgOiAwLFxuICAgICAgfSk7XG4gICAgICB3YWxrZXIub24oJ2RhdGEnLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB3YWxrZXIucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWl0ZW0uc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGZpbGVDb3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdG9yeUNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gICAgICAgIGxhc3RGaWxlUHJvY2Vzc2VkID0gQi50cnkoYXN5bmMgKCkgPT4gYXdhaXQgY2FsbGJhY2soaXRlbS5wYXRoLCBpdGVtLnN0YXRzLmlzRGlyZWN0b3J5KCkpKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkb25lID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoaXRlbS5wYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhbGtlci5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyLCBpdGVtKSB7XG4gICAgICAgIGxvZy53YXJuKGBHb3QgYW4gZXJyb3Igd2hpbGUgd2Fsa2luZyAnJHtpdGVtLnBhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgLy8ga2xhdyBjYW5ub3QgZ2V0IGJhY2sgZnJvbSBhbiBFTk9FTlQgZXJyb3JcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgIGxvZy53YXJuKCdBbGwgZmlsZXMgbWF5IG5vdCBoYXZlIGJlZW4gYWNjZXNzZWQnKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXN0RmlsZVByb2Nlc3NlZFxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGBVbmV4cGVjdGVkIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgVHJhdmVyc2VkICR7cGx1cmFsaXplKCdkaXJlY3RvcnknLCBkaXJlY3RvcnlDb3VudCwgdHJ1ZSl9IGAgK1xuICAgICAgICBgYW5kICR7cGx1cmFsaXplKCdmaWxlJywgZmlsZUNvdW50LCB0cnVlKX0gYCArXG4gICAgICAgIGBpbiAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNNaWxsaVNlY29uZHMudG9GaXhlZCgwKX1tc2ApO1xuICAgICAgaWYgKHdhbGtlcikge1xuICAgICAgICB3YWxrZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogUmVhZHMgdGhlIGNsb3Nlc3QgYHBhY2thZ2UuanNvbmAgZmlsZSBmcm9tIGFic29sdXRlIHBhdGggYGRpcmAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgLSBEaXJlY3RvcnkgdG8gc2VhcmNoIGZyb21cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgZGlyYCBpcyBub3QgYSBub25lbXB0eSBzdHJpbmcgb3IgcmVsYXRpdmUgcGF0aFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2VyZSBwcm9ibGVtcyBmaW5kaW5nIG9yIHJlYWRpbmcgYSBgcGFja2FnZS5qc29uYCBmaWxlXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEEgcGFyc2VkIGBwYWNrYWdlLmpzb25gXG4gICAqL1xuICByZWFkUGFja2FnZUpzb25Gcm9tIChkaXIpIHtcbiAgICBjb25zdCByb290ID0gZnMuZmluZFJvb3QoZGlyKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoX2ZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4ocm9vdCwgJ3BhY2thZ2UuanNvbicpLCAndXRmOCcpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gYEZhaWxlZCB0byByZWFkIGEgXFxgcGFja2FnZS5qc29uXFxgIGZyb20gZGlyIFxcYCR7ZGlyfVxcYDpcXG5cXG4ke2Vyci5tZXNzYWdlfWA7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRmluZHMgdGhlIHByb2plY3Qgcm9vdCBkaXJlY3RvcnkgZnJvbSBgZGlyYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpciAtIERpcmVjdG9yeSB0byBzZWFyY2ggZnJvbVxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBkaXJgIGlzIG5vdCBhIG5vbmVtcHR5IHN0cmluZyBvciByZWxhdGl2ZSBwYXRoXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3ZXJlIHByb2JsZW1zIGZpbmRpbmcgdGhlIHByb2plY3Qgcm9vdFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY2xvc2VzZXQgcGFyZW50IGRpciBjb250YWluaW5nIGBwYWNrYWdlLmpzb25gXG4gICAqL1xuICBmaW5kUm9vdCAoZGlyKSB7XG4gICAgaWYgKCFkaXIgfHwgIXBhdGguaXNBYnNvbHV0ZShkaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgZmluZFJvb3QoKWAgbXVzdCBiZSBwcm92aWRlZCBhIG5vbi1lbXB0eSwgYWJzb2x1dGUgcGF0aCcpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmaW5kUm9vdENhY2hlZChkaXIpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGZpbmRSb290KClcXGAgY291bGQgbm90IGZpbmQgXFxgcGFja2FnZS5qc29uXFxgIGZyb20gJHtkaXJ9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIGFkZCB0aGUgc3VwcG9ydGVkIGBmc2AgZnVuY3Rpb25zXG5jb25zdCBzaW1wbGVzID0gW1xuICAnb3BlbicsICdjbG9zZScsICdhY2Nlc3MnLCAncmVhZEZpbGUnLCAnd3JpdGVGaWxlJywgJ3dyaXRlJywgJ3JlYWQnLFxuICAncmVhZGxpbmsnLCAnY2htb2QnLCAndW5saW5rJywgJ3JlYWRkaXInLCAnc3RhdCcsICdyZW5hbWUnLCAnbHN0YXQnLFxuICAnYXBwZW5kRmlsZScsICdyZWFscGF0aCcsICdzeW1saW5rJyxcbl07XG5mb3IgKGNvbnN0IHMgb2Ygc2ltcGxlcykge1xuICBmc1tzXSA9IEIucHJvbWlzaWZ5KF9mc1tzXSk7XG59XG5cbmNvbnN0IHN5bmNGdW5jdGlvbnMgPSBbXG4gICdjcmVhdGVSZWFkU3RyZWFtJyxcbiAgJ2NyZWF0ZVdyaXRlU3RyZWFtJyxcbl07XG5mb3IgKGNvbnN0IHMgb2Ygc3luY0Z1bmN0aW9ucykge1xuICBmc1tzXSA9IF9mc1tzXTtcbn1cblxuLy8gYWRkIHRoZSBjb25zdGFudHMgZnJvbSBgZnNgXG5jb25zdCBjb25zdGFudHMgPSBbXG4gICdGX09LJywgJ1JfT0snLCAnV19PSycsICdYX09LJywgJ2NvbnN0YW50cycsXG5dO1xuZm9yIChjb25zdCBjIG9mIGNvbnN0YW50cykge1xuICBmc1tjXSA9IF9mc1tjXTtcbn1cblxuZXhwb3J0IHsgZnMgfTtcbmV4cG9ydCBkZWZhdWx0IGZzO1xuIl0sImZpbGUiOiJsaWIvZnMuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
