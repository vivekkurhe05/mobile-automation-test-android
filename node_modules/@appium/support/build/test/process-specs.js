"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("source-map-support/register");

var teenProcess = _interopRequireWildcard(require("teen_process"));

var _sinon = _interopRequireDefault(require("sinon"));

var _index = require("../lib/index.js");

var _asyncbox = require("asyncbox");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SubProcess = teenProcess.SubProcess;
describe('process', function () {
  describe('getProcessIds', function () {
    let proc;
    before(async function () {
      proc = new SubProcess('tail', ['-f', __filename]);
      await proc.start();
    });
    after(async function () {
      await proc.stop();
    });
    it('should get return an array for existing process', async function () {
      let pids = await _index.process.getProcessIds('tail');
      pids.should.be.an.instanceof(Array);
    });
    it('should get process identifiers for existing process', async function () {
      let pids = await _index.process.getProcessIds('tail');
      pids.should.have.length.at.least(1);
    });
    it('should get an empty array when the process does not exist', async function () {
      let pids = await _index.process.getProcessIds('sadfgasdfasdf');
      pids.should.have.length(0);
    });
    it('should throw an error if pgrep fails', async function () {
      let tpMock = _sinon.default.mock(teenProcess);

      tpMock.expects('exec').throws({
        message: 'Oops',
        code: 2
      });
      await _index.process.getProcessIds('tail').should.eventually.be.rejectedWith(/Oops/);
      tpMock.restore();
    });
  });
  describe('killProcess', function () {
    let proc;
    beforeEach(async function () {
      proc = new SubProcess('tail', ['-f', __filename]);
      await proc.start();
    });
    afterEach(async function () {
      if (proc.isRunning) {
        await proc.stop();
      }
    });
    it('should kill process that is running', async function () {
      proc.isRunning.should.be.true;
      await _index.process.killProcess('tail');
      await (0, _asyncbox.retryInterval)(10, 100, async () => {
        proc.isRunning.should.be.false;
      });
    });
    it('should do nothing if the process does not exist', async function () {
      proc.isRunning.should.be.true;
      await _index.process.killProcess('asdfasdfasdf');
      await (0, _asyncbox.retryInterval)(10, 100, async () => {
        proc.isRunning.should.be.false;
      }).should.eventually.be.rejected;
    });
    it('should throw an error if pgrep fails', async function () {
      let tpMock = _sinon.default.mock(teenProcess);

      tpMock.expects('exec').throws({
        message: 'Oops',
        code: 2
      });
      await _index.process.killProcess('tail').should.eventually.be.rejectedWith(/Oops/);
      tpMock.restore();
    });
    it('should throw an error if pkill fails', async function () {
      let tpMock = _sinon.default.mock(teenProcess);

      tpMock.expects('exec').twice().onFirstCall().returns({
        stdout: '42\n'
      }).onSecondCall().throws({
        message: 'Oops',
        code: 2
      });
      await _index.process.killProcess('tail').should.eventually.be.rejectedWith(/Oops/);
      tpMock.restore();
    });
  });
});require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvcHJvY2Vzcy1zcGVjcy5qcyJdLCJuYW1lcyI6WyJTdWJQcm9jZXNzIiwidGVlblByb2Nlc3MiLCJkZXNjcmliZSIsInByb2MiLCJiZWZvcmUiLCJfX2ZpbGVuYW1lIiwic3RhcnQiLCJhZnRlciIsInN0b3AiLCJpdCIsInBpZHMiLCJwcm9jZXNzIiwiZ2V0UHJvY2Vzc0lkcyIsInNob3VsZCIsImJlIiwiYW4iLCJpbnN0YW5jZW9mIiwiQXJyYXkiLCJoYXZlIiwibGVuZ3RoIiwiYXQiLCJsZWFzdCIsInRwTW9jayIsInNpbm9uIiwibW9jayIsImV4cGVjdHMiLCJ0aHJvd3MiLCJtZXNzYWdlIiwiY29kZSIsImV2ZW50dWFsbHkiLCJyZWplY3RlZFdpdGgiLCJyZXN0b3JlIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsImlzUnVubmluZyIsInRydWUiLCJraWxsUHJvY2VzcyIsImZhbHNlIiwicmVqZWN0ZWQiLCJ0d2ljZSIsIm9uRmlyc3RDYWxsIiwicmV0dXJucyIsInN0ZG91dCIsIm9uU2Vjb25kQ2FsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUlBLE1BQU1BLFVBQVUsR0FBR0MsV0FBVyxDQUFDRCxVQUEvQjtBQUVBRSxRQUFRLENBQUMsU0FBRCxFQUFZLFlBQVk7QUFDOUJBLEVBQUFBLFFBQVEsQ0FBQyxlQUFELEVBQWtCLFlBQVk7QUFDcEMsUUFBSUMsSUFBSjtBQUNBQyxJQUFBQSxNQUFNLENBQUMsa0JBQWtCO0FBQ3ZCRCxNQUFBQSxJQUFJLEdBQUcsSUFBSUgsVUFBSixDQUFlLE1BQWYsRUFBdUIsQ0FBQyxJQUFELEVBQU9LLFVBQVAsQ0FBdkIsQ0FBUDtBQUNBLFlBQU1GLElBQUksQ0FBQ0csS0FBTCxFQUFOO0FBQ0QsS0FISyxDQUFOO0FBSUFDLElBQUFBLEtBQUssQ0FBQyxrQkFBa0I7QUFDdEIsWUFBTUosSUFBSSxDQUFDSyxJQUFMLEVBQU47QUFDRCxLQUZJLENBQUw7QUFHQUMs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TUFBTSxDQUFDUyxPQUFQO0FBQ0QsS0FUQyxDQUFGO0FBVUQsR0E5Q08sQ0FBUjtBQStDRCxDQS9FTyxDQUFSIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdGVlblByb2Nlc3MgZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi4vbGliL2luZGV4LmpzJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5cblxuXG5jb25zdCBTdWJQcm9jZXNzID0gdGVlblByb2Nlc3MuU3ViUHJvY2VzcztcblxuZGVzY3JpYmUoJ3Byb2Nlc3MnLCBmdW5jdGlvbiAoKSB7XG4gIGRlc2NyaWJlKCdnZXRQcm9jZXNzSWRzJywgZnVuY3Rpb24gKCkge1xuICAgIGxldCBwcm9jO1xuICAgIGJlZm9yZShhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jID0gbmV3IFN1YlByb2Nlc3MoJ3RhaWwnLCBbJy1mJywgX19maWxlbmFtZV0pO1xuICAgICAgYXdhaXQgcHJvYy5zdGFydCgpO1xuICAgIH0pO1xuICAgIGFmdGVyKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IHByb2Muc3RvcCgpO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgZ2V0IHJldHVybiBhbiBhcnJheSBmb3IgZXhpc3RpbmcgcHJvY2VzcycsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBwaWRzID0gYXdhaXQgcHJvY2Vzcy5nZXRQcm9jZXNzSWRzKCd0YWlsJyk7XG4gICAgICBwaWRzLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIGdldCBwcm9jZXNzIGlkZW50aWZpZXJzIGZvciBleGlzdGluZyBwcm9jZXNzJywgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IHBpZHMgPSBhd2FpdCBwcm9jZXNzLmdldFByb2Nlc3NJZHMoJ3RhaWwnKTtcbiAgICAgIHBpZHMuc2hvdWxkLmhhdmUubGVuZ3RoLmF0LmxlYXN0KDEpO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgZ2V0IGFuIGVtcHR5IGFycmF5IHdoZW4gdGhlIHByb2Nlc3MgZG9lcyBub3QgZXhpc3QnLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgcGlkcyA9IGF3YWl0IHByb2Nlc3MuZ2V0UHJvY2Vzc0lkcygnc2FkZmdhc2RmYXNkZicpO1xuICAgICAgcGlkcy5zaG91bGQuaGF2ZS5sZW5ndGgoMCk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBwZ3JlcCBmYWlscycsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCB0cE1vY2sgPSBzaW5vbi5tb2NrKHRlZW5Qcm9jZXNzKTtcbiAgICAgIHRwTW9jay5leHBlY3RzKCdleGVjJykudGhyb3dzKHttZXNzYWdlOiAnT29wcycsIGNvZGU6IDJ9KTtcblxuICAgICAgYXdhaXQgcHJvY2Vzcy5nZXRQcm9jZXNzSWRzKCd0YWlsJykuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9Pb3BzLyk7XG5cbiAgICAgIHRwTW9jay5yZXN0b3JlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdraWxsUHJvY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcHJvYztcbiAgICBiZWZvcmVFYWNoKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2MgPSBuZXcgU3ViUHJvY2VzcygndGFpbCcsIFsnLWYnLCBfX2ZpbGVuYW1lXSk7XG4gICAgICBhd2FpdCBwcm9jLnN0YXJ0KCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9jLmlzUnVubmluZykge1xuICAgICAgICBhd2FpdCBwcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIGtpbGwgcHJvY2VzcyB0aGF0IGlzIHJ1bm5pbmcnLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jLmlzUnVubmluZy5zaG91bGQuYmUudHJ1ZTtcbiAgICAgIGF3YWl0IHByb2Nlc3Mua2lsbFByb2Nlc3MoJ3RhaWwnKTtcblxuICAgICAgLy8gaXQgbWF5IHRha2UgYSBtb21lbnQgdG8gYWN0dWFsbHkgYmUgcmVnaXN0ZXJlZCBhcyBraWxsZWRcbiAgICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMTAsIDEwMCwgYXN5bmMgKCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICAgICAgcHJvYy5pc1J1bm5pbmcuc2hvdWxkLmJlLmZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBkbyBub3RoaW5nIGlmIHRoZSBwcm9jZXNzIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgcHJvYy5pc1J1bm5pbmcuc2hvdWxkLmJlLnRydWU7XG4gICAgICBhd2FpdCBwcm9jZXNzLmtpbGxQcm9jZXNzKCdhc2RmYXNkZmFzZGYnKTtcblxuICAgICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgxMCwgMTAwLCBhc3luYyAoKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgICAgICBwcm9jLmlzUnVubmluZy5zaG91bGQuYmUuZmFsc2U7XG4gICAgICB9KS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZDtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHBncmVwIGZhaWxzJywgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IHRwTW9jayA9IHNpbm9uLm1vY2sodGVlblByb2Nlc3MpO1xuICAgICAgdHBNb2NrLmV4cGVjdHMoJ2V4ZWMnKS50aHJvd3Moe21lc3NhZ2U6ICdPb3BzJywgY29kZTogMn0pO1xuXG4gICAgICBhd2FpdCBwcm9jZXNzLmtpbGxQcm9jZXNzKCd0YWlsJykuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9Pb3BzLyk7XG5cbiAgICAgIHRwTW9jay5yZXN0b3JlKCk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBwa2lsbCBmYWlscycsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCB0cE1vY2sgPSBzaW5vbi5tb2NrKHRlZW5Qcm9jZXNzKTtcbiAgICAgIHRwTW9jay5leHBlY3RzKCdleGVjJykudHdpY2UoKVxuICAgICAgICAub25GaXJzdENhbGwoKS5yZXR1cm5zKHtzdGRvdXQ6ICc0Mlxcbid9KVxuICAgICAgICAub25TZWNvbmRDYWxsKCkudGhyb3dzKHttZXNzYWdlOiAnT29wcycsIGNvZGU6IDJ9KTtcblxuICAgICAgYXdhaXQgcHJvY2Vzcy5raWxsUHJvY2VzcygndGFpbCcpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvT29wcy8pO1xuXG4gICAgICB0cE1vY2sucmVzdG9yZSgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sImZpbGUiOiJ0ZXN0L3Byb2Nlc3Mtc3BlY3MuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
