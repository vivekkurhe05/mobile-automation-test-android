"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _path = _interopRequireDefault(require("path"));

var util = _interopRequireWildcard(require("../lib/util"));

var _index = require("../lib/index");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

describe('#util', function () {
  let tmpRoot;
  let tmpFile;
  const content = 'YOLO';
  beforeEach(async function () {
    tmpRoot = await _index.tempDir.openDir();
    tmpFile = _path.default.resolve(tmpRoot, 'example.txt');
    await _index.fs.writeFile(tmpFile, content, 'utf8');
  });
  afterEach(async function () {
    if (tmpRoot) {
      await _index.fs.rimraf(tmpRoot);
    }

    tmpRoot = null;
  });
  describe('toInMemoryBase64()', function () {
    it('should convert a file to base64 encoding', async function () {
      const data = await util.toInMemoryBase64(tmpFile);
      const fileContent = await _index.fs.readFile(tmpFile);
      data.toString().should.eql(fileContent.toString('base64'));
    });
  });
  describe('getLockFileGuard()', function () {
    let tmpRoot;
    let lockFile;
    let testFile;

    async function guardedBehavior(text, msBeforeActing) {
      await _bluebird.default.delay(msBeforeActing);
      await _index.fs.appendFile(testFile, text, 'utf8');
      return text;
    }

    async function testFileContents() {
      return (await _index.fs.readFile(testFile)).toString('utf8');
    }

    beforeEach(async function () {
      tmpRoot = await _index.tempDir.openDir();
      lockFile = _path.default.resolve(tmpRoot, 'test.lock');
      testFile = _path.default.resolve(tmpRoot, 'test');
      await _index.fs.writeFile(testFile, 'a', 'utf8');
    });
    afterEach(async function () {
      try {
        await _bluebird.default.all([lockFile, testFile].map(p => _index.fs.unlink(p)));
      } catch (ign) {}
    });
    it('should lock a file during the given behavior', async function () {
      const guard = util.getLockFileGuard(lockFile);
      await guard.check().should.eventually.be.false;
      const guardPromise = guard(async () => await guardedBehavior('b', 500));
      await _bluebird.default.delay(200);
      await guard.check().should.eventually.be.true;
      await guardPromise;
      await guard.check().should.eventually.be.false;
      await testFileContents().should.eventually.eql('ab');
    });
    it('should recover a broken lock file', async function () {
      await _index.fs.writeFile(lockFile, 'dummy', 'utf8');
      const guard = util.getLockFileGuard(lockFile, {
        timeout: 3,
        tryRecovery: true
      });
      await guard(async () => await guardedBehavior('b', 500));
      await guard.check().should.eventually.be.false;
      await testFileContents().should.eventually.eql('ab');
    });
    it('should block other behavior until the lock is released', async function () {
      await testFileContents().should.eventually.eql('a');
      const unguardedPromise1 = guardedBehavior('b', 500);
      const unguardedPromise2 = guardedBehavior('c', 100);
      await unguardedPromise1;
      await unguardedPromise2;
      await testFileContents().should.eventually.eql('acb');
      const guard = util.getLockFileGuard(lockFile);
      const guardPromise1 = guard(async () => await guardedBehavior('b', 500));
      const guardPromise2 = guard(async () => await guardedBehavior('c', 100));
      await guardPromise1;
      await guardPromise2;
      await testFileContents().should.eventually.eql('acbbc');
    });
    it('should return the result of the guarded behavior', async function () {
      const guard = util.getLockFileGuard(lockFile);
      const guardPromise1 = guard(async () => await guardedBehavior('hello', 500));
      const guardPromise2 = guard(async () => await guardedBehavior('world', 100));
      const ret1 = await guardPromise1;
      const ret2 = await guardPromise2;
      ret1.should.eql('hello');
      ret2.should.eql('world');
    });
    it('should time out if the lock is not released', async function () {
      this.timeout(5000);
      const guard = util.getLockFileGuard(lockFile, {
        timeout: 0.5
      });
      const p1 = guard(async () => await guardedBehavior('hello', 1200));
      const p2 = guard(async () => await guardedBehavior('world', 10));
      await p2.should.eventually.be.rejectedWith(/not acquire lock/);
      await p1.should.eventually.eql('hello');
    });
    it('should still release lock if guarded behavior fails', async function () {
      this.timeout(5000);
      const guard = util.getLockFileGuard(lockFile);
      const p1 = guard(async () => {
        await _bluebird.default.delay(500);
        throw new Error('bad');
      });
      const p2 = guard(async () => await guardedBehavior('world', 100));
      await p1.should.eventually.be.rejectedWith(/bad/);
      await p2.should.eventually.eql('world');
    });
  });
});require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvdXRpbC1lMmUtc3BlY3MuanMiXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJ0bXBSb290IiwidG1wRmlsZSIsImNvbnRlbnQiLCJiZWZvcmVFYWNoIiwidGVtcERpciIsIm9wZW5EaXIiLCJwYXRoIiwicmVzb2x2ZSIsImZzIiwid3JpdGVGaWxlIiwiYWZ0ZXJFYWNoIiwicmltcmFmIiwiaXQiLCJkYXRhIiwidXRpbCIsInRvSW5NZW1vcnlCYXNlNjQiLCJmaWxlQ29udGVudCIsInJlYWRGaWxlIiwidG9TdHJpbmciLCJzaG91bGQiLCJlcWwiLCJsb2NrRmlsZSIsInRlc3RGaWxlIiwiZ3VhcmRlZEJlaGF2aW9yIiwidGV4dCIsIm1zQmVmb3JlQWN0aW5nIiwiQiIsImRlbGF5IiwiYXBwZW5kRmlsZSIsInRlc3RGaWxlQ29udGVudHMiLCJhbGwiLCJtYXAiLCJwIiwidW5saW5rIiwiaWduIiwiZ3VhcmQiLCJnZXRMb2NrRmlsZUd1YXJkIiwiY2hlY2siLCJldmVudHVhbGx5IiwiYmUiLCJmYWxzZSIsImd1YXJkUHJvbWlzZSIsInRydWUiLCJ0aW1lb3V0IiwidHJ5UmVjb3ZlcnkiLCJ1bmd1YXJkZWRQcm9taXNlMSIsInVuZ3VhcmRlZFByb21pc2UyIiwiZ3VhcmRQcm9taXNlMSIsImd1YXJkUHJvbWlzZTIiLCJyZXQxIiwicmV0MiIsInAxIiwicDIiLCJyZWplY3RlZFdpdGgiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBQSxRQUFRLENBQUMsT0FBRCxFQUFVLFlBQVk7QUFDNUIsTUFBSUMsT0FBSjtBQUNBLE1BQUlDLE9BQUo7QUFDQSxRQUFNQyxPQUFPLEdBQUcsTUFBaEI7QUFFQUMsRUFBQUEsVUFBVSxDQUFDLGtCQUFrQjtBQUMzQkgsSUFBQUEsT0FBTyxHQUFHLE1BQU1JLGVBQVFDLE9BQVIsRUFBaEI7QUFDQUosSUFBQUEsT0FBTyxHQUFHSyxjQUFLQyxPQUFMLENBQWFQLE9BQWIsRUFBc0IsYUFBdEIsQ0FBVjtBQUNBLFVBQU1RLFVBQUdDLFNBQUgsQ0FBYVIsT0FBYixFQUFzQkMsT0FBdEIsRUFBK0IsTUFBL0IsQ0FBTjtBQUNELEdBSlMsQ0FBVjtBQU1BUSxFQUFBQSxTQUFTLENBQUMsa0JBQWtCO0FBQzFCLFFBQUlWLE9BQUosRUFBYTtBQUNYLFlBQU1RLFVBQUdHLE1BQUgsQ0FBVVgsT0FBVixDQUFOO0FBQ0Q7O0FBQ0RBLElBQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0QsR0FMUSxDQUFUO0FBT0FELEVBQUFBLFFBQVEsQ0FBQyxvQkFBRCxFQUF1QixZQUFZO0FBQ3pDYSxJQUFBQSxFQUFFLENBQUMsMENBQUQsRUFBNkMsa0JBQWtCO0FBQy9ELFlBQU1DLElBQUksR0FBRyxNQUFNQyxJQUFJLENBQUNDLGdCQUFMLENBQXNCZCxPQUF0QixDQUFuQjtBQUNBLFlBQU1lLFdBQVcsR0FBRyxNQUFNUixVQUFHUyxRQUFILENBQVloQixPQUFaLENBQTFCO0FBQ0FZLE1BQUFBLElBQUksQ0FBQ0ssUUFBTCxHQUFnQkMsTUFBaEIsQ0FBdUJDLEdBQXZCLENBQTJCSixXQUFXLENBQUNFLFFBQVosQ0FBcUIsUUFBckIsQ0FBM0I7QUFDRCxLQUpDLENBQUY7QUFLRCxHQU5PLENBQVI7QUFRQW5CLEVBQUFBLFFBQVEsQ0FBQyxvQkFBRCxFQUF1QixZQUFZO0FBQ3pDLFFBQUlDLE9BQUo7QUFDQSxRQUFJcUIsUUFBSjtBQUNBLFFBQUlDLFFBQUo7O0FBRUEsbUJBQWVDLGVBQWYsQ0FBZ0NDLElBQWhDLEVBQXNDQyxjQUF0QyxFQUFzRDtBQUNwRCxZQUFNQyxrQkFBRUMsS0FBRixDQUFRRixjQUFSLENBQU47QUFDQSxZQUFNakIsVUFBR29CLFVBQUgsQ0FBY04sUUFBZCxFQUF3QkUsSUFBeEIsRUFBOEIsTUFBOUIsQ0FBTjtBQUNBLGFBQU9BLElBQVA7QUFDRDs7QUFFRCxtQkFBZUssZ0JBQWYsR0FBbUM7QUFDakMsYUFBTyxDQUFDLE1BQU1yQixVQUFHUyxRQUFILENBQVlLLFFBQVosQ0FBUCxFQUE4QkosUUFBOUIsQ0FBdUMsTUFBdkMsQ0FBUDtBQUNEOztBQUVEZixJQUFBQSxVQUFVLENBQUMsa0JBQWtCO0FBQzNCSCxNQUFBQSxPQUFPLEdBQUcsTUFBTUksZUFBUUMsT0FBUixFQUFoQjtBQUNBZ0IsTUFBQUEsUUFBUSxHQUFHZixjQUFLQyxPQUFMLENBQWFQLE9BQWIsRUFBc0IsV0FBdEIsQ0FBWDtBQUNBc0IsTUFBQUEsUUFBUSxHQUFHaEIsY0FBS0MsT0FBTCxDQUFhUCxPQUFiLEVBQXNCLE1BQXRCLENBQVg7QUFDQSxZQUFNUSxVQUFHQyxTQUFILENBQWFhLFFBQWIsRUFBdUIsR0FBdkIsRUFBNEIsTUFBNUIsQ0FBTjtBQUNELEtBTFMsQ0FBVjtBQU9BWixJQUFBQSxTQUFTLENBQUMsa0JBQWtCO0FBQzFCLFVBQUk7QUFDRixjQUFNZ0Isa0JBQUVJLEdBQUYsQ0FBTSxDQUFDVCxRQUFELEVBQVdDLFFBQVgsRUFBcUJTLEdBQXJCLENBQTBCQyxDQUFELElBQU94QixVQUFHeUIsTUFBSCxDQUFVRCxDQUFWLENBQWhDLENBQU4sQ0FBTjtBQUNELE9BRkQsQ0FFRSxPQUFPRSxHQUFQLEVBQVksQ0FBRTtBQUNqQixLQUpRLENBQVQ7QUFNQXRCLElBQUFBLEVBQUUsQ0FBQyw4Q0FBRCxFQUFpRCxrQkFBa0I7QUFDbkUsWUFBTXVCLEtBQUssR0FBR3JCLElBQUksQ0FBQ3NCLGdCQUFMLENBQXNCZixRQUF0QixDQUFkO0FBQ0EsWUFBTWMsS0FBSyxDQUFDRSxLQUFOLEdBQWNsQixNQUFkLENBQXFCbUIsVUFBckIsQ0FBZ0NDLEVBQWhDLENBQW1DQyxLQUF6QztBQUNBLFlBQU1DLFlBQVksR0FBR04sS0FBSyxDQUFDLFlBQVksTUFBTVosZUFBZSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQWxDLENBQTFCO0FBQ0EsWUFBTUcsa0JBQUVDLEtBQUYsQ0FBUSxHQUFSLENBQU47QUFDQSxZQUFNUSxLQUFLLENBQUNFLEtBQU4sR0FBY2xCLE1BQWQsQ0FBcUJtQixVQUFyQixDQUFnQ0MsRUFBaEMsQ0FBbUNHLElBQXpDO0FBQ0EsWUFBTUQsWUFBTjtBQUNBLFlBQU1OLEtBQUssQ0FBQ0UsS0FBTixHQUFjbEIsTUFBZCxDQUFxQm1CLFVBQXJCLENBQWdDQyxFQUFoQyxDQUFtQ0MsS0FBekM7QUFDQSxZQUFNWCxnQkFBZ0IsR0FBR1YsTUFBbkIsQ0FBMEJtQixVQUExQixDQUFxQ2xCLEdBQXJDLENBQXlDLElBQXpDLENBQU47QUFDRCxLQVRDLENBQUY7QUFXQVIsSUFBQUEsRUFBRSxDQUFDLG1DQUFELEVBQXNDLGtCQUFrQjtBQUN4RCxZQUFNSixVQUFHQyxTQUFILENBQWFZLFFBQWIsRUFBdUIsT0FBdkIsRUFBZ0MsTUFBaEMsQ0FBTjtBQUNBLFlBQU1jLEtBQUssR0FBR3JCLElBQUksQ0FBQ3NCLGdCQUFMLENBQXNCZixRQUF0QixFQUFnQztBQUM1Q3NCLFFBQUFBLE9BQU8sRUFBRSxDQURtQztBQUU1Q0MsUUFBQUEsV0FBVyxFQUFFO0FBRitCLE9BQWhDLENBQWQ7QUFJQSxZQUFNVCxLQUFLLENBQUMsWUFBWSxNQUFNWixlQUFlLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBbEMsQ0FBWDtBQUNBLFlBQU1ZLEtBQUssQ0FBQ0UsS0FBTixHQUFjbEIsTUFBZCxDQUFxQm1CLFVBQXJCLENBQWdDQyxFQUFoQyxDQUFtQ0MsS0FBekM7QUFDQSxZQUFNWCxnQkFBZ0IsR0FBR1YsTUFBbkIsQ0FBMEJtQixVQUExQixDQUFxQ2xCLEdBQXJDLENBQXlDLElBQXpDLENBQU47QUFDRCxLQVRDLENBQUY7QUFXQVIsSUFBQUEsRUFBRSxDQUFDLHdEQUFELEVBQTJELGtCQUFrQjtBQUU3RSxZQUFNaUIsZ0JBQWdCLEdBQUdWLE1BQW5CLENBQTBCbUIsVUFBMUIsQ0FBcUNsQixHQUFyQyxDQUF5QyxHQUF6QyxDQUFOO0FBQ0EsWUFBTXlCLGlCQUFpQixHQUFHdEIsZUFBZSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXpDO0FBQ0EsWUFBTXVCLGlCQUFpQixHQUFHdkIsZUFBZSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXpDO0FBQ0EsWUFBTXNCLGlCQUFOO0FBQ0EsWUFBTUMsaUJBQU47QUFDQSxZQUFNakIsZ0JBQWdCLEdBQUdWLE1BQW5CLENBQTBCbUIsVUFBMUIsQ0FBcUNsQixHQUFyQyxDQUF5QyxLQUF6QyxDQUFOO0FBR0EsWUFBTWUsS0FBSyxHQUFHckIsSUFBSSxDQUFDc0IsZ0JBQUwsQ0FBc0JmLFFBQXRCLENBQWQ7QUFDQSxZQUFNMEIsYUFBYSxHQUFHWixLQUFLLENBQUMsWUFBWSxNQUFNWixlQUFlLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBbEMsQ0FBM0I7QUFDQSxZQUFNeUIsYUFBYSxHQUFHYixLQUFLLENBQUMsWUFBWSxNQUFNWixlQUFlLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBbEMsQ0FBM0I7QUFDQSxZQUFNd0IsYUFBTjtBQUNBLFlBQU1DLGFBQU47QUFDQSxZQUFNbkIsZ0JBQWdCLEdBQUdWLE1BQW5CLENBQTBCbUIsVUFBMUIsQ0FBcUNsQixHQUFyQyxDQUF5QyxPQUF6QyxDQUFOO0FBQ0QsS0FoQkMsQ0FBRjtBQWtCQVIsSUFBQUEsRUFBRSxDQUFDLGtEQUFELEVBQXFELGtCQUFrQjtBQUN2RSxZQUFNdUIsS0FBSyxHQUFHckIsSUFBSSxDQUFDc0IsZ0JBQUwsQ0FBc0JmLFFBQXRCLENBQWQ7QUFDQSxZQUFNMEIsYUFBYSxHQUFHWixLQUFLLENBQUMsWUFBWSxNQUFNWixlQUFlLENBQUMsT0FBRCxFQUFVLEdBQVYsQ0FBbEMsQ0FBM0I7QUFDQSxZQUFNeUIsYUFBYSxHQUFHYixLQUFLLENBQUMsWUFBWSxNQUFNWixlQUFlLENBQUMsT0FBRCxFQUFVLEdBQVYsQ0FBbEMsQ0FBM0I7QUFDQSxZQUFNMEIsSUFBSSxHQUFHLE1BQU1GLGFBQW5CO0FBQ0EsWUFBTUcsSUFBSSxHQUFHLE1BQU1GLGFBQW5CO0FBQ0FDLE1BQUFBLElBQUksQ0FBQzlCLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixPQUFoQjtBQUNBOEIsTUFBQUEsSUFBSSxDQUFDL0IsTUFBTCxDQUFZQyxHQUFaLENBQWdCLE9BQWhCO0FBQ0QsS0FSQyxDQUFGO0FBVUFSLElBQUFBLEVBQUUsQ0FBQyw2Q0FBRCxFQUFnRCxrQkFBa0I7QUFDbEUsV0FBSytCLE9BQUwsQ0FBYSxJQUFiO0FBQ0EsWUFBTVIsS0FBSyxHQUFHckIsSUFBSSxDQUFDc0IsZ0JBQUwsQ0FBc0JmLFFBQXRCLEVBQWdDO0FBQUNzQixRQUFBQSxPQUFPLEVBQUU7QUFBVixPQUFoQyxDQUFkO0FBQ0EsWUFBTVEsRUFBRSxHQUFHaEIsS0FBSyxDQUFDLFlBQVksTUFBTVosZUFBZSxDQUFDLE9BQUQsRUFBVSxJQUFWLENBQWxDLENBQWhCO0FBQ0EsWUFBTTZCLEVBQUUsR0FBR2pCLEtBQUssQ0FBQyxZQUFZLE1BQU1aLGVBQWUsQ0FBQyxPQUFELEVBQVUsRUFBVixDQUFsQyxDQUFoQjtBQUNBLFlBQU02QixFQUFFLENBQUNqQyxNQUFILENBQVVtQixVQUFWLENBQXFCQyxFQUFyQixDQUF3QmMsWUFBeEIsQ0FBcUMsa0JBQXJDLENBQU47QUFDQSxZQUFNRixFQUFFLENBQUNoQyxNQUFILENBQVVtQixVQUFWLENBQXFCbEIsR0FBckIsQ0FBeUIsT0FBekIsQ0FBTjtBQUNELEtBUEMsQ0FBRjtBQVNBUixJQUFBQSxFQUFFLENBQUMscURBQUQsRUFBd0Qsa0JBQWtCO0FBQzFFLFdBQUsrQixPQUFMLENBQWEsSUFBYjtBQUNBLFlBQU1SLEtBQUssR0FBR3JCLElBQUksQ0FBQ3NCLGdCQUFMLENBQXNCZixRQUF0QixDQUFkO0FBQ0EsWUFBTThCLEVBQUUsR0FBR2hCLEtBQUssQ0FBQyxZQUFZO0FBQzNCLGNBQU1ULGtCQUFFQyxLQUFGLENBQVEsR0FBUixDQUFOO0FBQ0EsY0FBTSxJQUFJMkIsS0FBSixDQUFVLEtBQVYsQ0FBTjtBQUNELE9BSGUsQ0FBaEI7QUFJQSxZQUFNRixFQUFFLEdBQUdqQixLQUFLLENBQUMsWUFBWSxNQUFNWixlQUFlLENBQUMsT0FBRCxFQUFVLEdBQVYsQ0FBbEMsQ0FBaEI7QUFDQSxZQUFNNEIsRUFBRSxDQUFDaEMsTUFBSCxDQUFVbUIsVUFBVixDQUFxQkMsRUFBckIsQ0FBd0JjLFlBQXhCLENBQXFDLEtBQXJDLENBQU47QUFDQSxZQUFNRCxFQUFFLENBQUNqQyxNQUFILENBQVVtQixVQUFWLENBQXFCbEIsR0FBckIsQ0FBeUIsT0FBekIsQ0FBTjtBQUNELEtBVkMsQ0FBRjtBQVdELEdBbEdPLENBQVI7QUFvR0QsQ0E5SE8sQ0FBUiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi9saWIvdXRpbCc7XG5pbXBvcnQgeyB0ZW1wRGlyLCBmcyB9IGZyb20gJy4uL2xpYi9pbmRleCc7XG5cblxuZGVzY3JpYmUoJyN1dGlsJywgZnVuY3Rpb24gKCkge1xuICBsZXQgdG1wUm9vdDtcbiAgbGV0IHRtcEZpbGU7XG4gIGNvbnN0IGNvbnRlbnQgPSAnWU9MTyc7XG5cbiAgYmVmb3JlRWFjaChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICAgIHRtcEZpbGUgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ2V4YW1wbGUudHh0Jyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRtcEZpbGUsIGNvbnRlbnQsICd1dGY4Jyk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRtcFJvb3QpIHtcbiAgICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgICB9XG4gICAgdG1wUm9vdCA9IG51bGw7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd0b0luTWVtb3J5QmFzZTY0KCknLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGEgZmlsZSB0byBiYXNlNjQgZW5jb2RpbmcnLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdXRpbC50b0luTWVtb3J5QmFzZTY0KHRtcEZpbGUpO1xuICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZSh0bXBGaWxlKTtcbiAgICAgIGRhdGEudG9TdHJpbmcoKS5zaG91bGQuZXFsKGZpbGVDb250ZW50LnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRMb2NrRmlsZUd1YXJkKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHRtcFJvb3Q7XG4gICAgbGV0IGxvY2tGaWxlO1xuICAgIGxldCB0ZXN0RmlsZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGd1YXJkZWRCZWhhdmlvciAodGV4dCwgbXNCZWZvcmVBY3RpbmcpIHtcbiAgICAgIGF3YWl0IEIuZGVsYXkobXNCZWZvcmVBY3RpbmcpO1xuICAgICAgYXdhaXQgZnMuYXBwZW5kRmlsZSh0ZXN0RmlsZSwgdGV4dCwgJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHRlc3RGaWxlQ29udGVudHMgKCkge1xuICAgICAgcmV0dXJuIChhd2FpdCBmcy5yZWFkRmlsZSh0ZXN0RmlsZSkpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuXG4gICAgYmVmb3JlRWFjaChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gICAgICBsb2NrRmlsZSA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAndGVzdC5sb2NrJyk7XG4gICAgICB0ZXN0RmlsZSA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAndGVzdCcpO1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHRlc3RGaWxlLCAnYScsICd1dGY4Jyk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgQi5hbGwoW2xvY2tGaWxlLCB0ZXN0RmlsZV0ubWFwKChwKSA9PiBmcy51bmxpbmsocCkpKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9jayBhIGZpbGUgZHVyaW5nIHRoZSBnaXZlbiBiZWhhdmlvcicsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gdXRpbC5nZXRMb2NrRmlsZUd1YXJkKGxvY2tGaWxlKTtcbiAgICAgIGF3YWl0IGd1YXJkLmNoZWNrKCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUuZmFsc2U7XG4gICAgICBjb25zdCBndWFyZFByb21pc2UgPSBndWFyZChhc3luYyAoKSA9PiBhd2FpdCBndWFyZGVkQmVoYXZpb3IoJ2InLCA1MDApKTtcbiAgICAgIGF3YWl0IEIuZGVsYXkoMjAwKTtcbiAgICAgIGF3YWl0IGd1YXJkLmNoZWNrKCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUudHJ1ZTtcbiAgICAgIGF3YWl0IGd1YXJkUHJvbWlzZTtcbiAgICAgIGF3YWl0IGd1YXJkLmNoZWNrKCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUuZmFsc2U7XG4gICAgICBhd2FpdCB0ZXN0RmlsZUNvbnRlbnRzKCkuc2hvdWxkLmV2ZW50dWFsbHkuZXFsKCdhYicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWNvdmVyIGEgYnJva2VuIGxvY2sgZmlsZScsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShsb2NrRmlsZSwgJ2R1bW15JywgJ3V0ZjgnKTtcbiAgICAgIGNvbnN0IGd1YXJkID0gdXRpbC5nZXRMb2NrRmlsZUd1YXJkKGxvY2tGaWxlLCB7XG4gICAgICAgIHRpbWVvdXQ6IDMsXG4gICAgICAgIHRyeVJlY292ZXJ5OiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBndWFyZChhc3luYyAoKSA9PiBhd2FpdCBndWFyZGVkQmVoYXZpb3IoJ2InLCA1MDApKTtcbiAgICAgIGF3YWl0IGd1YXJkLmNoZWNrKCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUuZmFsc2U7XG4gICAgICBhd2FpdCB0ZXN0RmlsZUNvbnRlbnRzKCkuc2hvdWxkLmV2ZW50dWFsbHkuZXFsKCdhYicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBibG9jayBvdGhlciBiZWhhdmlvciB1bnRpbCB0aGUgbG9jayBpcyByZWxlYXNlZCcsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGZpcnN0IHByb3ZlIHRoYXQgd2l0aG91dCBhIGxvY2ssIHdlIGdldCByYWNlc1xuICAgICAgYXdhaXQgdGVzdEZpbGVDb250ZW50cygpLnNob3VsZC5ldmVudHVhbGx5LmVxbCgnYScpO1xuICAgICAgY29uc3QgdW5ndWFyZGVkUHJvbWlzZTEgPSBndWFyZGVkQmVoYXZpb3IoJ2InLCA1MDApO1xuICAgICAgY29uc3QgdW5ndWFyZGVkUHJvbWlzZTIgPSBndWFyZGVkQmVoYXZpb3IoJ2MnLCAxMDApO1xuICAgICAgYXdhaXQgdW5ndWFyZGVkUHJvbWlzZTE7XG4gICAgICBhd2FpdCB1bmd1YXJkZWRQcm9taXNlMjtcbiAgICAgIGF3YWl0IHRlc3RGaWxlQ29udGVudHMoKS5zaG91bGQuZXZlbnR1YWxseS5lcWwoJ2FjYicpO1xuXG4gICAgICAvLyBub3cgcHJvdmUgdGhhdCB3aXRoIGEgbG9jaywgd2UgZG9uJ3QgZ2V0IGFueSBpbnRlcmxvcGVyc1xuICAgICAgY29uc3QgZ3VhcmQgPSB1dGlsLmdldExvY2tGaWxlR3VhcmQobG9ja0ZpbGUpO1xuICAgICAgY29uc3QgZ3VhcmRQcm9taXNlMSA9IGd1YXJkKGFzeW5jICgpID0+IGF3YWl0IGd1YXJkZWRCZWhhdmlvcignYicsIDUwMCkpO1xuICAgICAgY29uc3QgZ3VhcmRQcm9taXNlMiA9IGd1YXJkKGFzeW5jICgpID0+IGF3YWl0IGd1YXJkZWRCZWhhdmlvcignYycsIDEwMCkpO1xuICAgICAgYXdhaXQgZ3VhcmRQcm9taXNlMTtcbiAgICAgIGF3YWl0IGd1YXJkUHJvbWlzZTI7XG4gICAgICBhd2FpdCB0ZXN0RmlsZUNvbnRlbnRzKCkuc2hvdWxkLmV2ZW50dWFsbHkuZXFsKCdhY2JiYycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgZ3VhcmRlZCBiZWhhdmlvcicsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gdXRpbC5nZXRMb2NrRmlsZUd1YXJkKGxvY2tGaWxlKTtcbiAgICAgIGNvbnN0IGd1YXJkUHJvbWlzZTEgPSBndWFyZChhc3luYyAoKSA9PiBhd2FpdCBndWFyZGVkQmVoYXZpb3IoJ2hlbGxvJywgNTAwKSk7XG4gICAgICBjb25zdCBndWFyZFByb21pc2UyID0gZ3VhcmQoYXN5bmMgKCkgPT4gYXdhaXQgZ3VhcmRlZEJlaGF2aW9yKCd3b3JsZCcsIDEwMCkpO1xuICAgICAgY29uc3QgcmV0MSA9IGF3YWl0IGd1YXJkUHJvbWlzZTE7XG4gICAgICBjb25zdCByZXQyID0gYXdhaXQgZ3VhcmRQcm9taXNlMjtcbiAgICAgIHJldDEuc2hvdWxkLmVxbCgnaGVsbG8nKTtcbiAgICAgIHJldDIuc2hvdWxkLmVxbCgnd29ybGQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGltZSBvdXQgaWYgdGhlIGxvY2sgaXMgbm90IHJlbGVhc2VkJywgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50aW1lb3V0KDUwMDApO1xuICAgICAgY29uc3QgZ3VhcmQgPSB1dGlsLmdldExvY2tGaWxlR3VhcmQobG9ja0ZpbGUsIHt0aW1lb3V0OiAwLjV9KTtcbiAgICAgIGNvbnN0IHAxID0gZ3VhcmQoYXN5bmMgKCkgPT4gYXdhaXQgZ3VhcmRlZEJlaGF2aW9yKCdoZWxsbycsIDEyMDApKTtcbiAgICAgIGNvbnN0IHAyID0gZ3VhcmQoYXN5bmMgKCkgPT4gYXdhaXQgZ3VhcmRlZEJlaGF2aW9yKCd3b3JsZCcsIDEwKSk7XG4gICAgICBhd2FpdCBwMi5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoL25vdCBhY3F1aXJlIGxvY2svKTtcbiAgICAgIGF3YWl0IHAxLnNob3VsZC5ldmVudHVhbGx5LmVxbCgnaGVsbG8nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3RpbGwgcmVsZWFzZSBsb2NrIGlmIGd1YXJkZWQgYmVoYXZpb3IgZmFpbHMnLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRpbWVvdXQoNTAwMCk7XG4gICAgICBjb25zdCBndWFyZCA9IHV0aWwuZ2V0TG9ja0ZpbGVHdWFyZChsb2NrRmlsZSk7XG4gICAgICBjb25zdCBwMSA9IGd1YXJkKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgQi5kZWxheSg1MDApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCcpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwMiA9IGd1YXJkKGFzeW5jICgpID0+IGF3YWl0IGd1YXJkZWRCZWhhdmlvcignd29ybGQnLCAxMDApKTtcbiAgICAgIGF3YWl0IHAxLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvYmFkLyk7XG4gICAgICBhd2FpdCBwMi5zaG91bGQuZXZlbnR1YWxseS5lcWwoJ3dvcmxkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG59KTtcbiJdLCJmaWxlIjoidGVzdC91dGlsLWUyZS1zcGVjcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
